<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>技能五 vs 子祺 - 五子棋对战</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css" />
    <style>
      :root {
        --bg-gradient: radial-gradient(1400px 900px at 20% 0%, #f5f7fb, #eef2f7 55%, #e9edf5);
        --surface: #ffffff;
        --card-bg: #ffffff;
        --card-border: rgba(15,23,42,0.12);
        --accent: #0f172a;
        --accent-2: #06b6d4;
        --win: #22c55e;
        --lose: #ef4444;
        --text: #0f172a;
        --muted: #475569;
        --grid: #cbd5e1;
        --black: #0f172a;
        --white: #e5e7eb;
        --shadow: 0 12px 30px rgba(0,0,0,0.12);
      }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: Inter, -apple-system, system-ui, Segoe UI, Roboto, Ubuntu, Cantarell, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--text);
        background: var(--bg-gradient);
        min-height: 100vh;
        display: grid;
        place-items: center;
        overflow-x: hidden;
        /* 全局移动端触摸优化 */
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        touch-action: manipulation;
      }
      .container {
        width: min(1200px, 95vw);
        display: grid;
        grid-template-columns: 1fr 360px;
        gap: 20px;
      }
      .container.start { grid-template-columns: 1fr; width: min(980px, 95vw); }
      .container.normal { grid-template-columns: 1fr; }
      @media (max-width: 980px) {
        .container { grid-template-columns: 1fr; }
      }
      .card {
        background: var(--card-bg);
        border: 1px solid var(--card-border);
        border-radius: 16px;
        box-shadow: var(--shadow);
      }
      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        border-bottom: 1px solid var(--card-border);
      }
      .header .left { display: flex; align-items: center; gap: 12px; }
      .icon-btn { display:inline-flex; align-items:center; justify-content:center; width:36px; height:36px; border-radius:999px; border:1px solid var(--card-border); background: #ffffff; color: var(--text); cursor:pointer; transition: background .2s ease, border-color .2s ease, transform .1s ease, color .2s ease; }
      .icon-btn svg { width:20px; height:20px; }
      .icon-btn:hover { background: rgba(15,23,42,0.06); color: var(--text); border-color: var(--card-border); }
      .icon-btn:active { transform: translateY(1px); }
      .icon-btn:focus-visible { outline: none; box-shadow: 0 0 0 2px rgba(15,23,42,0.18); }
      .title {
        font-weight: 700;
        letter-spacing: 0.5px;
        display: flex; gap: 10px; align-items: center;
        color: var(--text);
        background: none;
        -webkit-text-fill-color: var(--text);
      }
      .badge { padding: 6px 10px; border-radius: 999px; font-size: 12px; color: var(--text); background: #f8fafc; border: 1px solid var(--card-border); }
      .badge.black { background: #f8fafc; }
      .badge.white { background: #f8fafc; }
      .board-wrap { padding: 20px; }
      .board {
        aspect-ratio: 1 / 1;
        max-width: 740px;
        width: 100%;
        margin: 0 auto;
        background: linear-gradient(180deg, #f1e4c8, #e0c991);
        border-radius: 16px;
        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.12), var(--shadow);
        position: relative;
        overflow: hidden;
        /* 移动端触摸优化 */
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        touch-action: manipulation;
      }
      @media (max-width: 768px) {
        .board {
          max-width: 90vw;
          border-radius: 8px;
        }
      }
      .grid { 
        position: absolute; 
        inset: 16px; 
        cursor: pointer; 
        z-index: 1;
        /* 防止移动端触摸高亮和遮罩闪烁 */
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        touch-action: manipulation;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        outline: none;
        border: none;
        background: transparent;
      }
      .grid canvas { width: 100%; height: 100%; display: block; pointer-events: none; }
      /* 按钮（苹果风） */
      .btn { padding:10px 14px; border-radius:12px; border:1px solid var(--card-border); background:#ffffff; color: var(--text); cursor:pointer; transition: .2s ease; }
      .btn:hover { transform: translateY(-1px); filter: brightness(1.04); }
      .btn:active { transform: translateY(0); }
      /* 统一变体按钮为中性浅色，避免多彩分散 */
      .btn.accent, .btn.success, .btn.danger { background: #ffffff; color: var(--text); border-color: var(--card-border); }
      /* 统一技能说明按钮颜色（柔和中性） */
      .btn.skill { background: #f8fafc; color: var(--text); border-color: #e2e8f0; }
      .btn.skill:hover { filter: brightness(1.05); }
      
      /* 移动端专用触摸优化 */
      @media (hover: none) and (pointer: coarse) {
        * {
          -webkit-tap-highlight-color: transparent !important;
          -webkit-touch-callout: none !important;
          -webkit-user-select: none !important;
          user-select: none !important;
        }
        .board, .grid, .board * {
          -webkit-tap-highlight-color: transparent !important;
          -webkit-touch-callout: none !important;
          touch-action: manipulation !important;
          -webkit-appearance: none !important;
          outline: none !important;
        }
        .btn:active, .icon-btn:active {
          transform: none !important;
        }
      }
      
      /* 模式选择卡片留白 */
      .start-wrap .mode-choices { display:grid; grid-template-columns: 1fr 1fr; gap: 16px; }
      .start-wrap .mode-card { background: var(--card-bg); border:1px solid var(--card-border); border-radius:16px; padding: 16px; box-shadow: var(--shadow); }
      .start-wrap .desc { color: var(--muted); }
      .pieces { position: absolute; inset: 16px; pointer-events: none; z-index: 3; }
      .piece {
        position: absolute;
        width: 28px; height: 28px;
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 3;
      }
      @media (max-width: 768px) {
        .piece {
          width: 20px; height: 20px;
        }
      }
      @media (max-width: 480px) {
        .piece {
          width: 16px; height: 16px;
        }
      }
      .stone {
        width: 100%; height: 100%;
        border-radius: 50%;
        box-shadow: 0 8px 18px rgba(0,0,0,0.28), inset 0 -3px 7px rgba(0,0,0,0.28), inset 0 4px 10px rgba(255,255,255,0.35);
        transition: transform 0.18s ease, box-shadow 0.2s ease;
        border: 1px solid rgba(0,0,0,0.25);
      }
      .stone.black { background: radial-gradient(circle at 35% 30%, #374151, #0b0f1a 70%); }
      .stone.white { background: radial-gradient(circle at 40% 35%, #f3f4f6, #cbd5e1 70%); }
      
      /* 移形换影技能选中效果 */
      .stone.selected {
        box-shadow: 
          0 0 0 3px var(--accent),
          0 0 0 6px rgba(124, 58, 237, 0.3),
          0 8px 18px rgba(0,0,0,0.35), 
          inset 0 -4px 8px rgba(0,0,0,0.35), 
          inset 0 4px 10px rgba(255,255,255,0.35);
        transform: scale(1.1);
        animation: selectedPulse 1.5s ease-in-out infinite;
      }
      
      @keyframes selectedPulse {
        0%, 100% { 
          box-shadow: 
            0 0 0 3px var(--accent),
            0 0 0 6px rgba(124, 58, 237, 0.3),
            0 8px 18px rgba(0,0,0,0.35), 
            inset 0 -4px 8px rgba(0,0,0,0.35), 
            inset 0 4px 10px rgba(255,255,255,0.35);
        }
        50% { 
          box-shadow: 
            0 0 0 4px var(--accent),
            0 0 0 8px rgba(124, 58, 237, 0.5),
            0 8px 18px rgba(0,0,0,0.35), 
            inset 0 -4px 8px rgba(0,0,0,0.35), 
            inset 0 4px 10px rgba(255,255,255,0.35);
        }
      }
      .hint { position: absolute; inset: 16px; pointer-events: none; z-index: 2; }
      .hint-dot {
        position: absolute; width: 10px; height: 10px; border-radius: 50%;
        background: rgba(0,0,0,0.35);
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      @media (max-width: 768px) {
        .hint-dot {
          width: 8px; height: 8px;
        }
      }
      @media (max-width: 480px) {
        .hint-dot {
          width: 6px; height: 6px;
        }
      }
      .controls { padding: 16px; display: grid; gap: 12px; }
      .row { display: flex; gap: 10px; align-items: center; justify-content: space-between; }
      .btn {
        padding: 10px 14px;
        border-radius: 12px;
        border: 1px solid var(--card-border);
        background: #ffffff;
        color: var(--text);
        cursor: pointer;
        transition: transform .18s ease, filter .18s ease;
        font-weight: 600;
        letter-spacing: .2px;
      }
      .btn:hover { transform: translateY(-1px); filter: brightness(1.04); }
      .btn:disabled { opacity: .45; cursor: not-allowed; }
      .btn.accent, .btn.danger, .btn.success { background: #ffffff; color: var(--text); border-color: var(--card-border); }
      .panel { padding: 16px; }
      .status { font-family: JetBrains Mono, monospace; color: var(--muted); font-size: 13px; }
      .skill-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
      .skill-card { padding: 12px; border-radius: 12px; border: 1px solid var(--card-border); background: #ffffff; }
      .skill-card h4 { margin: 6px 0; font-size: 14px; }
      .count { font-size: 12px; color: var(--muted); }
      .footer { padding: 10px 16px; border-top: 1px solid var(--card-border); display: flex; justify-content: space-between; align-items: center; }
      .link { color: #0ea5e9; text-decoration: none; }
      .modal-backdrop { position: fixed; inset: 0; background: rgba(15,23,42,1); display: grid; place-items: center; z-index: 9998; }
      .modal { width: min(720px, 92vw); background: #ffffff; border: 1px solid var(--card-border); border-radius: 18px; box-shadow: var(--shadow); z-index: 9999; }
      .modal .content { padding: 16px 18px; }
      .modal h3 { margin: 0; }
      .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,.7); color: #fff; padding: 10px 14px; border-radius: 999px; box-shadow: var(--shadow); }
      /* 开始界面样式 */
      .start-wrap { max-width: 980px; margin: 48px auto; padding: 20px; }
      .mode-choices { display: grid; grid-template-columns: repeat(2, 1fr); gap: 18px; align-items: stretch; }
      .mode-card { padding: 18px; border-radius: 16px; border: 1px solid var(--card-border); background: #ffffff; box-shadow: var(--shadow); display: flex; flex-direction: column; min-height: 220px; }
      .mode-card h3 { margin: 0 0 8px 0; }
      .mode-card .desc { color: var(--muted); font-size: 14px; margin-bottom: 12px; }
      .mode-card .actions { margin-top: auto; display: flex; gap: 10px; }
      .form { padding: 18px; border-radius: 16px; border: 1px dashed var(--card-border); }
      .form-row { display:flex; align-items:center; gap:10px; margin-bottom:10px; }
      .form-row input[type="text"] { flex:1; padding:8px 10px; border-radius:10px; border:1px solid var(--card-border); background: rgba(255,255,255,0.06); color: var(--text); }
      .form-row input[type="color"] { width:42px; height:32px; padding:0; border:none; background: transparent; }
      /* 数字输入隐藏上下箭头，支持直接输入 */
      .form-row input[type="number"] { width: 90px; padding:8px 10px; border-radius:10px; border:1px solid var(--card-border); background:#ffffff; color: var(--text); appearance: textfield; -moz-appearance: textfield; }
      .form-row input[type="number"]::-webkit-outer-spin-button,
      .form-row input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
      .color-dot { display:inline-block; width:12px; height:12px; border-radius:999px; margin-left:8px; border:1px solid rgba(255,255,255,0.35); vertical-align:middle; }
      
      /* 当前玩家横幅（柔和苹果风） */
      .current-player-banner {
        text-align: center;
        margin: 20px 0;
        padding: 16px 24px;
        background: #ffffff;
        border: 1px solid var(--card-border);
        border-radius: 16px;
        box-shadow: var(--shadow);
      }
      .player-turn {
        font-size: 22px;
        font-weight: 700;
        color: var(--text);
        letter-spacing: .5px;
      }
      .winner-banner {
        font-size: 24px;
        font-weight: 800;
        color: var(--accent);
        letter-spacing: 1px;
      }
      .frozen-notice {
        display: block;
        font-size: 14px;
        color: var(--muted);
        margin-top: 6px;
        font-weight: 500;
      }
      
      @keyframes playerTurnPulse {
        0%, 100% { 
          transform: scale(1);
          text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }
        50% { 
          transform: scale(1.02);
          text-shadow: 0 4px 16px rgba(124, 58, 237, 0.4);
        }
      }
      
      @keyframes winnerGlow {
        0% { 
          text-shadow: 0 2px 12px rgba(251, 191, 36, 0.6);
        }
        100% { 
          text-shadow: 0 4px 24px rgba(251, 191, 36, 0.9), 0 0 40px rgba(251, 191, 36, 0.3);
        }
      }
      
      /* 响应式设计 */
      @media (max-width: 768px) {
        .mode-choices { grid-template-columns: 1fr; }
        .current-player-banner {
          margin: 16px 0;
          padding: 12px 16px;
        }
        
        .player-turn { font-size: 20px; }
        .winner-banner { font-size: 22px; }
        .frozen-notice { font-size: 13px; }
      }
      
      @media (max-width: 480px) {
        .player-turn {
          font-size: 18px;
        }
        
        .winner-banner {
          font-size: 20px;
        }
        
        .frozen-notice {
          font-size: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel" data-type="module" data-presets="env,react">
      const SIZE = 15;

      const createEmptyBoard = () => Array.from({ length: SIZE }, () => Array(SIZE).fill(null));

      const starPoints = [
        [3,3],[3,11],[11,3],[11,11],[7,7]
      ];

      function useToast() {
        const [msg, setMsg] = React.useState(null);
        const show = React.useCallback((text) => {
          setMsg(text);
          setTimeout(() => setMsg(null), 1800);
        }, []);
        return { msg, show };
      }

      function drawGrid(canvas) {
        const dpr = window.devicePixelRatio || 1;
        // 使用布局尺寸，避免 CSS transform 影响计算
        const baseW = canvas.offsetWidth;
        const baseH = canvas.offsetHeight;
        canvas.width = Math.max(1, Math.floor(baseW * dpr));
        canvas.height = Math.max(1, Math.floor(baseH * dpr));
        const ctx = canvas.getContext('2d');
        ctx.setTransform(1,0,0,1,0,0);
        ctx.scale(dpr, dpr);
        ctx.clearRect(0,0,baseW, baseH);
        ctx.strokeStyle = '#2b3547';
        ctx.lineWidth = 1;
        const padding = 0;
        const cellSize = (baseW) / (SIZE - 1);
        for (let i = 0; i < SIZE; i++) {
          const pos = padding + i * cellSize;
          ctx.beginPath(); ctx.moveTo(padding, pos); ctx.lineTo(baseW - padding, pos); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(pos, padding); ctx.lineTo(pos, baseH - padding); ctx.stroke();
        }
        // star points
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        starPoints.forEach(([r,c]) => {
          const x = padding + c * cellSize;
          const y = padding + r * cellSize;
          ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fill();
        });
      }

      function calcWin(board, lastRow, lastCol) {
        if (lastRow == null || lastCol == null) return null;
        const color = board[lastRow][lastCol];
        if (color == null) return null;
        const dirs = [[1,0],[0,1],[1,1],[1,-1]];
        const inBounds = (r,c)=> r>=0 && r<SIZE && c>=0 && c<SIZE;
        for (const [dr,dc] of dirs) {
          let count = 1;
          let r = lastRow+dr, c = lastCol+dc;
          while (inBounds(r,c) && board[r][c]===color) { count++; r+=dr; c+=dc; }
          r = lastRow-dr; c = lastCol-dc;
          while (inBounds(r,c) && board[r][c]===color) { count++; r-=dr; c-=dc; }
          if (count >= 5) return color;
        }
        return null;
      }

      function App(){
        const [gameMode, setGameMode] = React.useState(null); // null -> start, 'skill' | 'normal'
        const [players, setPlayers] = React.useState([]); // 普通模式玩家数组 {id,name,color}
        const [currentIndex, setCurrentIndex] = React.useState(0);
        const defaultColors = ['#111827','#f3f4f6','#e11d48','#2563eb','#10b981','#f59e0b','#8b5cf6','#0ea5e9'];
        const [normalConfig, setNormalConfig] = React.useState({
          count: 2,
          players: [
            { name:'玩家1', color:'#111827', type:'human', difficulty:'easy' },
            { name:'玩家2', color:'#f3f4f6', type:'human', difficulty:'easy' }
          ]
        });
        const [showNormalConfig, setShowNormalConfig] = React.useState(false);
        const ensureConfigCount = React.useCallback((n)=>{
          setNormalConfig(prev=>{
            let arr = prev.players.slice(0, n);
            while(arr.length < n){
              const i = arr.length;
              arr.push({ name:`玩家${i+1}`, color: defaultColors[i % defaultColors.length], type:'human', difficulty:'easy' });
            }
            return { ...prev, count:n, players: arr };
          });
        },[]);

        // 允许把默认的“2”删除后再输入新数字；失焦时再校正到 ≥2
        const handleCountChange = React.useCallback((e)=>{
          const v = e.target.value;
          if (v === '') { // 输入为空时，暂不强制回填，便于替换输入
            setNormalConfig(prev => ({ ...prev, count: '' }));
            return;
          }
          const n = Number(v);
          if (Number.isNaN(n)) return;
          ensureConfigCount(Math.max(2, n));
        }, [ensureConfigCount]);

        const [board, setBoard] = React.useState(createEmptyBoard);
        const [current, setCurrent] = React.useState('black');
        const [names] = React.useState({ black: '技能五', white: '子祺' });
        const [frozen, setFrozen] = React.useState({ black:false, white:false });
        const [skillsUsed, setSkillsUsed] = React.useState({
          black: { remove:false, freeze:false, instant:false, swap:false, add:false },
          white: { remove:false, freeze:false, instant:false, swap:false, add:false },
        });
        const [winner, setWinner] = React.useState(null);
        const [lastMove, setLastMove] = React.useState(null);
        const [aiThinking, setAiThinking] = React.useState(false);
        const [skillMode, setSkillMode] = React.useState(null); // { type: 'remove'|'add'|'swap', step?:1|2, first?:{r,c} }
        const [selectedPiece, setSelectedPiece] = React.useState(null); // 移形换影技能选中的棋子位置 {r, c}
        const [showRules, setShowRules] = React.useState(false);
        // 拖动与缩放状态
        const [panMode, setPanMode] = React.useState(false);
        const [dragging, setDragging] = React.useState(false);
        const dragOriginRef = React.useRef(null);
        const [pan, setPan] = React.useState({ x: 0, y: 0 });
        const [zoom, setZoom] = React.useState(1);
        const toast = useToast();

        const canvasRef = React.useRef(null);
        React.useEffect(()=>{ if(canvasRef.current) drawGrid(canvasRef.current); });

        const cellSize = React.useMemo(()=>{
          const grid = document.querySelector('.grid');
          if (!grid) return 0; const rect = grid.getBoundingClientRect(); return (rect.width) / (SIZE - 1);
        }, [board]);

        const placePiece = (row,col,color) => {
          setBoard(prev => {
            if (prev[row][col]) return prev;
            const next = prev.map(r=>r.slice());
            next[row][col] = color;
            return next;
          });
          setLastMove({ row, col });
        };

        // ===== 普通模式 AI 逻辑与辅助函数 =====
        const inBoundsN = (r,c)=> r>=0 && r<SIZE && c>=0 && c<SIZE;
        function wouldWinAtN(board, r, c, pid){
          if (board[r][c] != null) return false;
          const dirs = [[1,0],[0,1],[1,1],[1,-1]];
          for (const [dr,dc] of dirs){
            let count = 1;
            let rr=r+dr, cc=c+dc;
            while(inBoundsN(rr,cc) && board[rr][cc]===pid){ count++; rr+=dr; cc+=dc; }
            rr=r-dr; cc=c-dc;
            while(inBoundsN(rr,cc) && board[rr][cc]===pid){ count++; rr-=dr; cc-=dc; }
            if (count>=5) return true;
          }
          return false;
        }

        function listEmptyN(board){
          const cells=[];
          for(let r=0;r<SIZE;r++){
            for(let c=0;c<SIZE;c++){
              if(board[r][c]==null) cells.push([r,c]);
            }
          }
          return cells;
        }

        function hasNeighbourN(board, r, c){
          for(let dr=-1;dr<=1;dr++){
            for(let dc=-1;dc<=1;dc++){
              if(dr===0 && dc===0) continue;
              const rr=r+dr, cc=c+dc;
              if(inBoundsN(rr,cc) && board[rr][cc]!=null) return true;
            }
          }
          return false;
        }

        function scoreCellN(board, r, c, pid){
          const dirs=[[1,0],[0,1],[1,1],[1,-1]];
          const opponents = players.map(p=>p.id).filter(id=>id!==pid);
          let selfBest=0, oppBest=0;
          for(const [dr,dc] of dirs){
            let self=1, rr=r+dr, cc=c+dc;
            while(inBoundsN(rr,cc) && board[rr][cc]===pid){ self++; rr+=dr; cc+=dc; }
            rr=r-dr; cc=c-dc;
            while(inBoundsN(rr,cc) && board[rr][cc]===pid){ self++; rr-=dr; cc-=dc; }
            selfBest=Math.max(selfBest,self);
            let oppDirBest=0;
            for(const oid of opponents){
              let opp=1; rr=r+dr; cc=c+dc;
              while(inBoundsN(rr,cc) && board[rr][cc]===oid){ opp++; rr+=dr; cc+=dc; }
              rr=r-dr; cc=c-dc;
              while(inBoundsN(rr,cc) && board[rr][cc]===oid){ opp++; rr-=dr; cc-=dc; }
              oppDirBest=Math.max(oppDirBest, opp);
            }
            oppBest=Math.max(oppBest, oppDirBest);
          }
          const centerBias = (Math.abs(r-(SIZE/2)) + Math.abs(c-(SIZE/2)));
          const centerScore = 8 - Math.min(8, centerBias);
          return (selfBest*selfBest*2) + (oppBest*oppBest) + centerScore + (hasNeighbourN(board,r,c)?5:0);
        }

        function chooseAIMove(board, pid, difficulty){
          const empties=listEmptyN(board);
          if(empties.length===0) return null;
          for(const [r,c] of empties){ if(wouldWinAtN(board,r,c,pid)) return {r,c}; }
          const opponents = players.map(p=>p.id).filter(id=>id!==pid);
          for(const [r,c] of empties){
            for(const oid of opponents){ if(wouldWinAtN(board,r,c,oid)) return {r,c}; }
          }
          if(difficulty==='easy'){
            const near=empties.filter(([r,c])=>hasNeighbourN(board,r,c));
            const pool = near.length>0?near:empties;
            const [r,c]=pool[Math.floor(Math.random()*pool.length)];
            return {r,c};
          }
          if(difficulty==='medium'){
            let best=null, bestScore=-Infinity;
            for(const [r,c] of empties){
              const s=scoreCellN(board,r,c,pid);
              if(s>bestScore){ bestScore=s; best={r,c}; }
            }
            return best;
          }
          let bests=[]; let bestScore=-Infinity;
          for(const [r,c] of empties){
            const s=scoreCellN(board,r,c,pid);
            if(s>bestScore){ bestScore=s; bests=[{r,c}]; }
            else if(s===bestScore){ bests.push({r,c}); }
          }
          if(bests.length===1) return bests[0];
          const near=bests.filter(m=>hasNeighbourN(board,m.r,m.c));
          return (near[0]||bests[0]);
        }

        function placeNormalAt(r,c,pid){
          setBoard(prev=>{
            const next=prev.map(row=>row.slice());
            next[r][c]=pid;
            return next;
          });
          setLastMove({ r, c });
          setCurrentIndex(i => (i + 1) % players.length);
        }

        // 棋盘拖动事件处理（启用拖动模式时生效）
        const onGridPointerDown = (e) => {
          if (!panMode) return;
          setDragging(true);
          dragOriginRef.current = { x: e.clientX, y: e.clientY };
          try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
          e.preventDefault();
        };
        const onGridPointerMove = (e) => {
          if (!panMode || !dragging) return;
          const orig = dragOriginRef.current;
          const dx = e.clientX - orig.x;
          const dy = e.clientY - orig.y;
          setPan(prev => ({ x: prev.x + dx, y: prev.y + dy }));
          dragOriginRef.current = { x: e.clientX, y: e.clientY };
        };
        const endGridDrag = (e) => {
          if (!dragging) return;
          setDragging(false);
          try { e.currentTarget.releasePointerCapture(e.pointerId); } catch {}
        };

        const handleBoardClick = (e) => {
          if (winner != null) return;
          
          // 防止移动端双重触发
          e.preventDefault();
          // 启用拖动模式时，阻止落子，避免误触
          if (panMode || dragging) return;
          
          const rect = e.currentTarget.getBoundingClientRect();
          // 显示坐标（已受缩放影响）
          const xScaled = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
          const yScaled = Math.max(0, Math.min(rect.height, e.clientY - rect.top));
          // 转回基础坐标：除以缩放因子
          const gridEl = e.currentTarget;
          const baseW = gridEl.offsetWidth;
          const csBase = baseW / (SIZE - 1);
          const xBase = xScaled / zoom;
          const yBase = yScaled / zoom;
          let col = Math.round(xBase / csBase);
          let row = Math.round(yBase / csBase);
          col = Math.max(0, Math.min(SIZE-1, col));
          row = Math.max(0, Math.min(SIZE-1, row));

          // 普通模式：仅落子与轮换，不含技能/冻结
          if (gameMode === 'normal') {
            if (players[currentIndex]?.type === 'ai') return;
            if (board[row][col]) return;
            const pid = currentIndex; // 用玩家索引标记棋盘
            setBoard(prev=>{
              const next = prev.map(r=>r.slice());
              next[row][col] = pid;
              return next;
            });
            setLastMove({ row, col });
            setCurrentIndex(i => (i + 1) % players.length);
            return;
          }

          // Skill targeting mode
          if (skillMode) {
            const other = current === 'black' ? 'white' : 'black';
            if (skillMode.type === 'remove') {
              if (board[row][col] === other) {
                setBoard(prev => {
                  const next = prev.map(r=>r.slice());
                  next[row][col] = null;
                  return next;
                });
                setSkillsUsed(s => ({ ...s, [current]: { ...s[current], remove:true } }));
                setSkillMode(null);
                toast.show('棋子被丢进了什刹海，你可以再落子一次');
                // 飞沙走石技能：移除棋子后不切换回合，当前玩家可以再落子一次
              }
              return;
            }
            if (skillMode.type === 'add') {
              if (!board[row][col]) {
                placePiece(row, col, current);
                setSkillsUsed(s => ({ ...s, [current]: { ...s[current], add:true } }));
                setSkillMode(null);
                toast.show('神来之笔已使用，你可以再落子一次');
                // 神来之笔技能：放置棋子后不切换回合，当前玩家可以再落子一次
              }
              return;
            }
            if (skillMode.type === 'swap') {
              if (skillMode.step === 1) {
                // 第一步：选择己方棋子
                if (board[row][col] === current) {
                  // 检查是否点击的是已选中的棋子
                  if (selectedPiece && selectedPiece.r === row && selectedPiece.c === col) {
                    // 取消选中
                    setSelectedPiece(null);
                    toast.show('已取消选择，请重新选择己方棋子');
                  } else {
                    // 选中新的棋子（包括重新选择）
                    setSkillMode({ type:'swap', step:2, first:{ r:row, c:col } });
                    setSelectedPiece({ r: row, c: col }); // 设置选中的棋子
                    toast.show('已重新选择，现在请选择对方棋子进行交换');
                  }
                }
                return;
              } else if (skillMode.step === 2) {
                // 第二步：选择对方棋子进行交换；允许取消或改选己方棋子
                // 点击己方棋子：取消或改选
                if (board[row][col] === current) {
                  // 点击同一个己方棋子：取消选中并回到第一步
                  if (selectedPiece && selectedPiece.r === row && selectedPiece.c === col) {
                    setSelectedPiece(null);
                    setSkillMode({ type:'swap', step:1 });
                    toast.show('已取消选择，请重新选择己方棋子');
                    return;
                  }
                  // 点击其他己方棋子：改选为新的己方棋子，保持第二步状态
                  setSelectedPiece({ r: row, c: col });
                  setSkillMode({ type:'swap', step:2, first:{ r:row, c:col } });
                  toast.show('已重新选择，现在请选择对方棋子进行交换');
                  return;
                }

                // 点击对方棋子：执行交换
                if (board[row][col] === other) {
                  const a = skillMode.first;
                  setBoard(prev => {
                    const next = prev.map(r=>r.slice());
                    next[a.r][a.c] = other;
                    next[row][col] = current;
                    return next;
                  });
                  setSkillsUsed(s => ({ ...s, [current]: { ...s[current], swap:true } }));
                  setSkillMode(null);
                  setSelectedPiece(null); // 清除选中状态
                  toast.show('移形换影已完成，你可以再落子一次');
                  // 移形换影技能：交换完成后不切换回合，当前玩家可以再落子一次
                }
                return;
              }
            }
          }

          // Freeze skip check
          if (gameMode === 'skill' && frozen[current]) {
            setFrozen(prev => ({ ...prev, [current]: false }));
            setCurrent(c => c === 'black' ? 'white' : 'black');
            return;
          }

          // Normal placement
          if (board[row][col] || winner) return; // 如果位置已占用或游戏结束，直接返回
          
          if (gameMode === 'skill') {
            setBoard(prev => {
              const next = prev.map(r=>r.slice());
              next[row][col] = current;
              return next;
            });
            setLastMove({ row, col });
            const nextTurn = current === 'black' ? 'white' : 'black';
            if (frozen[nextTurn]) {
              // auto-skip opponent: clear freeze and keep current turn
              setFrozen(prev => ({ ...prev, [nextTurn]: false }));
              // 保持当前玩家继续下棋，不切换
            } else {
              setCurrent(nextTurn);
            }
          }
        };

        React.useEffect(()=>{
          if (lastMove) {
            const w = calcWin(board, lastMove.row, lastMove.col);
            if (w != null) setWinner(w);
          }
        }, [board, lastMove]);

        // 普通模式：AI 自动回合
        React.useEffect(()=>{
          if (gameMode !== 'normal' || winner != null) return;
          const cur = players[currentIndex];
          if (!cur || cur.type !== 'ai') return;
          if (aiThinking) return;
          setAiThinking(true);
          setTimeout(()=>{
            const move = chooseAIMove(board, cur.id, cur.difficulty || 'easy');
            if (move) {
              const {r,c}=move;
              if(!board[r][c]){
                placeNormalAt(r,c,cur.id);
              }
            }
            setAiThinking(false);
          }, 350);
        }, [gameMode, currentIndex, board, players, winner, aiThinking]);

        React.useEffect(()=>{
          if (winner != null) {
            const name = gameMode === 'skill'
              ? (winner === 'black' ? names.black : names.white)
              : (players[winner]?.name || '玩家');
            toast.show(`${name} 获胜！恭喜连成五子！`);
          }
        }, [winner, gameMode, players]);

        const reset = () => {
          setBoard(createEmptyBoard());
          setWinner(null);
          setLastMove(null);
          setSelectedPiece(null);
          if (gameMode === 'skill') {
            setCurrent('black');
            setFrozen({ black:false, white:false });
            setSkillsUsed({ black: { remove:false, freeze:false, instant:false, swap:false, add:false }, white: { remove:false, freeze:false, instant:false, swap:false, add:false } });
            setSkillMode(null);
          } else if (gameMode === 'normal') {
            setCurrentIndex(0);
            setAiThinking(false);
          }
        };

        const startSkillGame = () => {
          setGameMode('skill');
          reset();
        };
        const startNormalGame = () => {
          const cfg = normalConfig.players.filter(Boolean).slice(0, normalConfig.count);
          if (cfg.length < 2) { toast.show('普通模式至少需要2位玩家'); return; }
          const ps = cfg.map((p,i)=>({ ...p, id:i }));
          setPlayers(ps);
          setGameMode('normal');
          setBoard(createEmptyBoard());
          setWinner(null);
          setLastMove(null);
          setCurrentIndex(0);
          setSkillMode(null);
          setAiThinking(false);
        };

        // Skills
        const useRemove = () => {
          if (winner) return;
          if (skillsUsed[current].remove) return;
          setSkillMode({ type:'remove' });
          setSelectedPiece(null); // 清除之前的选中状态
          toast.show('请选择要移除的对手棋子');
        };

        const useFreeze = () => {
          if (winner) return;
          if (skillsUsed[current].freeze) return;
          const other = current === 'black' ? 'white' : 'black';
          setFrozen(prev => ({ ...prev, [other]: true }));
          setSkillsUsed(s => ({ ...s, [current]: { ...s[current], freeze:true } }));
        };

        const useInstant = () => {
          if (winner) return;
          if (skillsUsed[current].instant) return;
          setSkillsUsed(s => ({ ...s, [current]: { ...s[current], instant:true } }));
          setWinner(current);
        };

        const useSwap = () => {
          if (winner) return;
          if (skillsUsed[current].swap) return;
          setSkillMode({ type:'swap', step:1 });
          setSelectedPiece(null); // 清除之前的选中状态
          toast.show('请选择己方棋子（可重新选择或点击已选中棋子取消）');
        };

        const useAdd = () => {
          if (winner) return;
          if (skillsUsed[current].add) return;
          setSkillMode({ type:'add' });
          setSelectedPiece(null); // 清除之前的选中状态
          toast.show('选择任意位置放置一子');
        };

        const pieces = [];
        const gridEl = document.querySelector('.grid');
        const cs = gridEl ? (gridEl.offsetWidth) / (SIZE - 1) : 0;

        for (let r=0;r<SIZE;r++) {
          for (let c=0;c<SIZE;c++) {
            const v = board[r][c];
            if (v == null) continue;
            const x = c * cs;
            const y = r * cs;
            const isSelected = selectedPiece && selectedPiece.r === r && selectedPiece.c === c;
            const stoneClass = gameMode === 'skill' ? `stone ${v}${isSelected ? ' selected' : ''}` : `stone${isSelected ? ' selected' : ''}`;
            const stoneStyle = gameMode === 'normal' ? { background: players[v]?.color || '#ffffff' } : undefined;
            pieces.push(
              <div key={`${r}-${c}`} className="piece" style={{ left: x, top: y }}>
                <div className={stoneClass} style={stoneStyle} />
              </div>
            );
          }
        }

        const skillsPanel = (
          <div className="skill-grid">
            <div className="skill-card">
              <h4>飞沙走石</h4>
              <p className="count">剩余：{skillsUsed[current].remove ? 0 : 1}</p>
              <button className="btn skill" disabled={skillsUsed[current].remove || !!winner} onClick={useRemove}>移除对手任意一枚棋子</button>
            </div>
            <div className="skill-card">
              <h4>静如止水</h4>
              <p className="count">剩余：{skillsUsed[current].freeze ? 0 : 1}</p>
              <button className="btn skill" disabled={skillsUsed[current].freeze || !!winner} onClick={useFreeze}>冻结对方一回合</button>
            </div>
            <div className="skill-card">
              <h4>力拔山兮</h4>
              <p className="count">剩余：{skillsUsed[current].instant ? 0 : 1}</p>
              <button className="btn skill" disabled={skillsUsed[current].instant || !!winner} onClick={useInstant}>终极技能：直接获得胜利</button>
            </div>
            <div className="skill-card">
              <h4>移形换影</h4>
              <p className="count">剩余：{skillsUsed[current].swap ? 0 : 1}</p>
              <button className="btn skill" disabled={skillsUsed[current].swap || !!winner} onClick={useSwap}>交换双方一枚棋子</button>
            </div>
            <div className="skill-card">
              <h4>神来之笔</h4>
              <p className="count">剩余：{skillsUsed[current].add ? 0 : 1}</p>
              <button className="btn skill" disabled={skillsUsed[current].add || !!winner} onClick={useAdd}>在任意位置放置一子</button>
            </div>
          </div>
        );

        return (
          <div className={`container${!gameMode ? ' start' : gameMode === 'normal' ? ' normal' : ''}`}>
            {!gameMode && (
              <div className="start-wrap">
                <div className="header" style={{marginBottom: '12px'}}>
                  <div className="title">选择游戏模式</div>
                </div>
                <div className="mode-choices">
                  <div className="mode-card">
                    <h3>普通五子棋模式</h3>
                    <p className="desc">自由设置玩家数量、名称与棋子颜色。</p>
                    <div className="actions">
                      <button className="btn success" onClick={()=>setShowNormalConfig(true)}>配置并开始</button>
                    </div>
                  </div>
                  <div className="mode-card">
                    <h3>技能五子棋模式</h3>
                    <p className="desc">包含技能面板与特殊规则，当前页面的玩法。</p>
                    <div className="actions">
                      <button className="btn accent" onClick={startSkillGame}>进入技能模式</button>
                    </div>
                  </div>
                </div>
              </div>
            )}
            {gameMode && (
            <div className="card">
              <div className="header">
                <div className="left">
                  <button className="icon-btn" title="返回模式选择" aria-label="返回模式选择" onClick={()=>{ setGameMode(null); setShowRules(false); setShowNormalConfig(false); }}>
                    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                      <path d="M3 10.5L12 3l9 7.5" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                      <path d="M5 10.5v9h14v-9" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                      <path d="M10 19.5v-5h4v5" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                    </svg>
                  </button>
                  <div className="title">
                  {gameMode === 'skill' ? (
                    <>
                      <span>技能五 vs 子祺</span>
                      <span className="badge black">黑：技能五</span>
                      <span className="badge white">白：子祺</span>
                    </>
                  ) : (
                    <>
                      <span>普通模式</span>
                      {players.map((p)=> (
                        <span key={`h-${p.id}`} className="badge" style={{borderColor:'rgba(255,255,255,0.25)'}}>
                          {p.name}{p.type === 'ai' ? '（电脑）' : ''}
                          <span className="color-dot" style={{background:p.color}}></span>
                        </span>
                      ))}
                    </>
                  )}
                  </div>
                </div>
              <div className="row">
                  <button className="btn" onClick={()=>setShowRules(true)}>规则说明</button>
                  <button className="btn" onClick={reset}>重新开始</button>
                  <button className="btn" onClick={()=>setPanMode(m=>!m)}>{panMode ? '拖动：开' : '拖动：关'}</button>
                  <button className="btn" onClick={()=>setZoom(z=>Math.min(2.5, +(z+0.2).toFixed(2)))}>放大</button>
                  <button className="btn" onClick={()=>setZoom(z=>Math.max(0.6, +(z-0.2).toFixed(2)))}>缩小</button>
                  <button className="btn" onClick={()=>{ setZoom(1); setPan({x:0,y:0}); }}>复位</button>
              </div>
              </div>
              {/* 大字报样式的当前玩家显示 */}
              <div className="current-player-banner">
                {winner != null ? (
                  <div className="winner-banner">
                    {gameMode === 'skill' ? (
                      <>🎉 胜者：{winner === 'black' ? names.black : names.white} 🎉</>
                    ) : (
                      <>🎉 胜者：{players[winner]?.name || '玩家'} 🎉</>
                    )}
                  </div>
                ) : (
                  <div className="player-turn">
                    {gameMode === 'skill' ? (
                      <>轮到：{current === 'black' ? `${names.black}（黑棋）` : `${names.white}（白棋）`}
                        {frozen[current] && <span className="frozen-notice">（本回合冻结，自动跳过）</span>}</>
                    ) : (
                      <>轮到：{players[currentIndex]?.name || '-'}
                        {players[currentIndex]?.type === 'ai' && (
                          <span>（电脑：{players[currentIndex]?.difficulty === 'hard' ? '困难' : (players[currentIndex]?.difficulty === 'medium' ? '中等' : '简单')}{aiThinking ? '，思考中…' : ''}）</span>
                        )}
                        <span className="frozen-notice">（普通模式：无技能）</span>
                      </>
                    )}
                  </div>
                )}
              </div>
              
              <div className="board-wrap">
                <div className="board">
                  <div
                    className="board-content"
                    onPointerDown={onGridPointerDown}
                    onPointerMove={onGridPointerMove}
                    onPointerUp={endGridDrag}
                    onPointerLeave={endGridDrag}
                    style={{
                      position:'absolute', inset:16,
                      transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
                      transformOrigin: 'center center',
                      cursor: panMode ? (dragging ? 'grabbing' : 'grab') : 'pointer',
                      touchAction: panMode ? 'none' : 'auto'
                    }}
                  >
                    <div className="grid" onClick={handleBoardClick} style={{position:'absolute', inset:0}}>
                      <canvas ref={canvasRef}/>
                    </div>
                    <div className="hint" style={{position:'absolute', inset:0}}>
                      {starPoints.map(([r,c]) => {
                        const x = c * cs; const y = r * cs;
                        return <div key={`star-${r}-${c}`} className="hint-dot" style={{ left: x, top: y }} />
                      })}
                    </div>
                    <div className="pieces" style={{position:'absolute', inset:0}}>{pieces}</div>
                  </div>
                </div>
              </div>
              <div className="footer">
                <div className="status">最近落子：{lastMove ? `${lastMove.row+1}, ${lastMove.col+1}` : '-'}</div>
              </div>
            </div>
            )}

            {gameMode === 'skill' && (
              <div className="card">
                <div className="panel">
                  <h3>技能面板</h3>
                  <p className="status">每种技能每局仅可使用一次。当前玩家：{current==='black'?names.black:names.white}</p>
                  {skillsPanel}
                </div>
              </div>
            )}

            {showRules && (
              <div className="modal-backdrop" onClick={()=>setShowRules(false)}>
                <div className="modal" onClick={(e)=>e.stopPropagation()}>
                  <div className="header">
                    <div className="title">五子棋规则说明</div>
                    <button className="btn" onClick={()=>setShowRules(false)}>关闭</button>
                  </div>
                  <div className="content">
                    <p>1. 棋盘为15×15，双方轮流在空位处落子，率先形成任意方向连续五子者获胜。</p>
                    <p>2. 星位仅为视觉参考，可在星位上落子。</p>
                    <p>3. 技能系统（每种每局一次）：</p>
                    <ul>
                      <li>飞沙走石：移除对手任意一枚棋子。</li>
                      <li>静如止水：冻结对方一回合，己方可连续下两步（通过跳过对方回合实现）。</li>
                      <li>力拔山兮：终极技能，直接获得胜利。</li>
                      <li>移形换影：交换双方各一枚已落子。</li>
                      <li>神来之笔：在任意位置额外放置一子。</li>
                    </ul>
                    <p>4. 在移动端，棋盘与面板会自适应布局。</p>
                  </div>
                </div>
              </div>
            )}

            {showNormalConfig && (
              <div className="modal-backdrop" onClick={()=>setShowNormalConfig(false)}>
                <div className="modal" onClick={(e)=>e.stopPropagation()}>
                  <div className="header">
                    <div className="title">普通模式配置</div>
                    <div className="row">
                      <button className="btn" onClick={()=>setShowNormalConfig(false)}>取消</button>
                      <button className="btn success" onClick={()=>{ startNormalGame(); setShowNormalConfig(false); }}>开始对局</button>
                    </div>
                  </div>
                  <div className="content">
                    <div className="form">
                      <div className="form-row">
                        <label>玩家人数（≥2）：</label>
                        <input type="number" min={2} value={normalConfig.count} onChange={handleCountChange} onBlur={(e)=>ensureConfigCount(Math.max(2, Number(e.target.value)||2))} />
                      </div>
                      {normalConfig.players.map((p,i)=> (
                        <div key={`cfgm-${i}`} className="form-row">
                          <span>玩家{i+1}：</span>
                          <input type="text" value={p.name} onChange={(e)=>{
                            const v = e.target.value;
                            setNormalConfig(prev=>{ const arr = prev.players.slice(); arr[i] = { ...arr[i], name: v }; return { ...prev, players: arr }; });
                          }} />
                          <input type="color" value={p.color} onChange={(e)=>{
                            const v = e.target.value;
                            setNormalConfig(prev=>{ const arr = prev.players.slice(); arr[i] = { ...arr[i], color: v }; return { ...prev, players: arr }; });
                          }} />
                          <select value={p.type || 'human'} onChange={(e)=>{
                            const v = e.target.value;
                            setNormalConfig(prev=>{ const arr = prev.players.slice(); arr[i] = { ...arr[i], type: v }; return { ...prev, players: arr }; });
                          }}>
                            <option value="human">人类</option>
                            <option value="ai">电脑</option>
                          </select>
                          {p.type === 'ai' && (
                            <select value={p.difficulty || 'easy'} onChange={(e)=>{
                              const v = e.target.value;
                              setNormalConfig(prev=>{ const arr = prev.players.slice(); arr[i] = { ...arr[i], difficulty: v }; return { ...prev, players: arr }; });
                            }}>
                              <option value="easy">简单</option>
                              <option value="medium">中等</option>
                              <option value="hard">困难</option>
                            </select>
                          )}
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              </div>
            )}

            {winner != null && (
              <div className="modal-backdrop" onClick={()=>{}}>
                <div className="modal" onClick={(e)=>e.stopPropagation()}>
                  <div className="header">
                    <div className="title">游戏结束</div>
                    <button className="btn" onClick={reset}>重新开始</button>
                  </div>
                  <div className="content">
                    <h3 style={{marginTop:0}}>
                      胜者：{gameMode === 'skill' ? (winner === 'black' ? names.black : names.white) : (players[winner]?.name || '玩家')}
                    </h3>
                    <p>恭喜达成连续五子！可点击右上角“重新开始”再战一局。</p>
                  </div>
                </div>
              </div>
            )}

            {toast.msg && <div className="toast">{toast.msg}</div>}
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App/>);
    </script>
  </body>
  </html>