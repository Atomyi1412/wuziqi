<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æŠ€èƒ½äº” vs å­ç¥º - äº”å­æ£‹å¯¹æˆ˜</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css" />
    <style>
      :root {
        --bg-gradient: radial-gradient(1200px 800px at 10% 10%, #1f2937, #0b1020 60%, #050914);
        --card-bg: rgba(255,255,255,0.06);
        --card-border: rgba(255,255,255,0.12);
        --accent: #7c3aed;
        --accent-2: #06b6d4;
        --win: #22c55e;
        --lose: #ef4444;
        --text: #e5e7eb;
        --muted: #94a3b8;
        --grid: #334155;
        --black: #0f172a;
        --white: #e5e7eb;
        --shadow: 0 10px 30px rgba(0,0,0,0.25);
      }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--text);
        background: linear-gradient(120deg, #0b1020, #0a0f1e), var(--bg-gradient);
        background-blend-mode: overlay;
        min-height: 100vh;
        display: grid;
        place-items: center;
        overflow-x: hidden;
      }
      .container {
        width: min(1200px, 95vw);
        display: grid;
        grid-template-columns: 1fr 360px;
        gap: 20px;
      }
      @media (max-width: 980px) {
        .container { grid-template-columns: 1fr; }
      }
      .card {
        background: var(--card-bg);
        border: 1px solid var(--card-border);
        border-radius: 16px;
        box-shadow: var(--shadow);
        backdrop-filter: saturate(120%) blur(8px);
      }
      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        border-bottom: 1px solid var(--card-border);
      }
      .title {
        font-weight: 700;
        letter-spacing: 0.5px;
        display: flex; gap: 10px; align-items: center;
      }
      .badge { padding: 6px 10px; border-radius: 999px; font-size: 12px; color: #0a0f1e; }
      .badge.black { background: #facc15; }
      .badge.white { background: #a7f3d0; }
      .board-wrap { padding: 16px; }
      .board {
        aspect-ratio: 1 / 1;
        max-width: 720px;
        width: 100%;
        margin: 0 auto;
        background: linear-gradient(180deg, #e6c792, #c9a86a);
        border-radius: 12px;
        box-shadow: inset 0 0 0 2px rgba(0,0,0,0.2), var(--shadow);
        position: relative;
        overflow: hidden;
      }
      @media (max-width: 768px) {
        .board {
          max-width: 90vw;
          border-radius: 8px;
        }
      }
      .grid { 
        position: absolute; 
        inset: 16px; 
        cursor: pointer; 
        z-index: 1;
        /* é˜²æ­¢ç§»åŠ¨ç«¯è§¦æ‘¸é«˜äº® */
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }
      .grid canvas { width: 100%; height: 100%; display: block; pointer-events: none; }
      .pieces { position: absolute; inset: 16px; pointer-events: none; z-index: 3; }
      .piece {
        position: absolute;
        width: 28px; height: 28px;
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 3;
      }
      @media (max-width: 768px) {
        .piece {
          width: 20px; height: 20px;
        }
      }
      @media (max-width: 480px) {
        .piece {
          width: 16px; height: 16px;
        }
      }
      .stone {
        width: 100%; height: 100%;
        border-radius: 50%;
        box-shadow: 0 8px 18px rgba(0,0,0,0.35), inset 0 -4px 8px rgba(0,0,0,0.35), inset 0 4px 10px rgba(255,255,255,0.35);
        transition: transform 0.18s ease, box-shadow 0.2s ease;
        border: 1px solid rgba(0,0,0,0.35);
      }
      .stone.black { background: radial-gradient(circle at 35% 30%, #374151, #0b0f1a 70%); }
      .stone.white { background: radial-gradient(circle at 40% 35%, #f3f4f6, #cbd5e1 70%); }
      
      /* ç§»å½¢æ¢å½±æŠ€èƒ½é€‰ä¸­æ•ˆæœ */
      .stone.selected {
        box-shadow: 
          0 0 0 3px var(--accent),
          0 0 0 6px rgba(124, 58, 237, 0.3),
          0 8px 18px rgba(0,0,0,0.35), 
          inset 0 -4px 8px rgba(0,0,0,0.35), 
          inset 0 4px 10px rgba(255,255,255,0.35);
        transform: scale(1.1);
        animation: selectedPulse 1.5s ease-in-out infinite;
      }
      
      @keyframes selectedPulse {
        0%, 100% { 
          box-shadow: 
            0 0 0 3px var(--accent),
            0 0 0 6px rgba(124, 58, 237, 0.3),
            0 8px 18px rgba(0,0,0,0.35), 
            inset 0 -4px 8px rgba(0,0,0,0.35), 
            inset 0 4px 10px rgba(255,255,255,0.35);
        }
        50% { 
          box-shadow: 
            0 0 0 4px var(--accent),
            0 0 0 8px rgba(124, 58, 237, 0.5),
            0 8px 18px rgba(0,0,0,0.35), 
            inset 0 -4px 8px rgba(0,0,0,0.35), 
            inset 0 4px 10px rgba(255,255,255,0.35);
        }
      }
      .hint { position: absolute; inset: 16px; pointer-events: none; z-index: 2; }
      .hint-dot {
        position: absolute; width: 10px; height: 10px; border-radius: 50%;
        background: rgba(0,0,0,0.35);
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      @media (max-width: 768px) {
        .hint-dot {
          width: 8px; height: 8px;
        }
      }
      @media (max-width: 480px) {
        .hint-dot {
          width: 6px; height: 6px;
        }
      }
      .controls { padding: 16px; display: grid; gap: 12px; }
      .row { display: flex; gap: 10px; align-items: center; justify-content: space-between; }
      .btn {
        padding: 10px 14px; border-radius: 10px; border: 1px solid var(--card-border);
        background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
        color: var(--text);
        cursor: pointer; transition: all .18s ease; font-weight: 600; letter-spacing: .2px;
      }
      .btn:hover { transform: translateY(-1px); box-shadow: var(--shadow); }
      .btn:disabled { opacity: .45; cursor: not-allowed; }
      .accent { border-color: rgba(124,58,237,.5); background: linear-gradient(180deg, rgba(124,58,237,.3), rgba(124,58,237,.1)); }
      .danger { border-color: rgba(239,68,68,.45); background: linear-gradient(180deg, rgba(239,68,68,.25), rgba(239,68,68,.08)); }
      .success { border-color: rgba(34,197,94,.45); background: linear-gradient(180deg, rgba(34,197,94,.25), rgba(34,197,94,.08)); }
      .panel { padding: 16px; }
      .status { font-family: JetBrains Mono, monospace; color: var(--muted); font-size: 13px; }
      .skill-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
      .skill-card { padding: 12px; border-radius: 12px; border: 1px dashed var(--card-border); background: rgba(255,255,255,0.10); }
      .skill-card h4 { margin: 6px 0; font-size: 14px; }
      .count { font-size: 12px; color: var(--muted); }
      .footer { padding: 10px 16px; border-top: 1px solid var(--card-border); display: flex; justify-content: space-between; align-items: center; }
      .link { color: #93c5fd; text-decoration: none; }
      .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.55); display: grid; place-items: center; }
      .modal { width: min(720px, 92vw); background: rgba(17,24,39,0.90); border: 1px solid rgba(255,255,255,0.20); border-radius: 18px; box-shadow: var(--shadow); }
      .modal .content { padding: 16px 18px; }
      .modal h3 { margin: 0; }
      .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,.7); color: #fff; padding: 10px 14px; border-radius: 999px; box-shadow: var(--shadow); }
      
      /* å¤§å­—æŠ¥æ ·å¼çš„å½“å‰ç©å®¶æ˜¾ç¤º */
      .current-player-banner {
        text-align: center;
        margin: 20px 0;
        padding: 16px 24px;
        background: linear-gradient(135deg, rgba(124, 58, 237, 0.15), rgba(59, 130, 246, 0.15));
        border: 2px solid rgba(124, 58, 237, 0.3);
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(124, 58, 237, 0.2);
      }
      
      .player-turn {
        font-size: 28px;
        font-weight: 700;
        color: #ffffff;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        letter-spacing: 1px;
        animation: playerTurnPulse 2s ease-in-out infinite;
      }
      
      .winner-banner {
        font-size: 32px;
        font-weight: 800;
        color: #fbbf24;
        text-shadow: 0 2px 12px rgba(251, 191, 36, 0.6);
        letter-spacing: 1.5px;
        animation: winnerGlow 1.5s ease-in-out infinite alternate;
      }
      
      .frozen-notice {
        display: block;
        font-size: 16px;
        color: #60a5fa;
        margin-top: 8px;
        font-weight: 500;
      }
      
      @keyframes playerTurnPulse {
        0%, 100% { 
          transform: scale(1);
          text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }
        50% { 
          transform: scale(1.02);
          text-shadow: 0 4px 16px rgba(124, 58, 237, 0.4);
        }
      }
      
      @keyframes winnerGlow {
        0% { 
          text-shadow: 0 2px 12px rgba(251, 191, 36, 0.6);
        }
        100% { 
          text-shadow: 0 4px 24px rgba(251, 191, 36, 0.9), 0 0 40px rgba(251, 191, 36, 0.3);
        }
      }
      
      /* å“åº”å¼è®¾è®¡ */
      @media (max-width: 768px) {
        .current-player-banner {
          margin: 16px 0;
          padding: 12px 16px;
        }
        
        .player-turn {
          font-size: 22px;
        }
        
        .winner-banner {
          font-size: 24px;
        }
        
        .frozen-notice {
          font-size: 14px;
        }
      }
      
      @media (max-width: 480px) {
        .player-turn {
          font-size: 18px;
        }
        
        .winner-banner {
          font-size: 20px;
        }
        
        .frozen-notice {
          font-size: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel" data-type="module" data-presets="env,react">
      const SIZE = 15;

      const createEmptyBoard = () => Array.from({ length: SIZE }, () => Array(SIZE).fill(null));

      const starPoints = [
        [3,3],[3,11],[11,3],[11,11],[7,7]
      ];

      function useToast() {
        const [msg, setMsg] = React.useState(null);
        const show = React.useCallback((text) => {
          setMsg(text);
          setTimeout(() => setMsg(null), 1800);
        }, []);
        return { msg, show };
      }

      function drawGrid(canvas) {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        ctx.clearRect(0,0,rect.width, rect.height);
        ctx.strokeStyle = '#2b3547';
        ctx.lineWidth = 1;
        const padding = 0;
        const cellSize = (rect.width) / (SIZE - 1);
        for (let i = 0; i < SIZE; i++) {
          const pos = padding + i * cellSize;
          ctx.beginPath(); ctx.moveTo(padding, pos); ctx.lineTo(rect.width - padding, pos); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(pos, padding); ctx.lineTo(pos, rect.height - padding); ctx.stroke();
        }
        // star points
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        starPoints.forEach(([r,c]) => {
          const x = padding + c * cellSize;
          const y = padding + r * cellSize;
          ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fill();
        });
      }

      function calcWin(board, lastRow, lastCol) {
        if (lastRow == null || lastCol == null) return null;
        const color = board[lastRow][lastCol];
        if (!color) return null;
        const dirs = [[1,0],[0,1],[1,1],[1,-1]];
        const inBounds = (r,c)=> r>=0 && r<SIZE && c>=0 && c<SIZE;
        for (const [dr,dc] of dirs) {
          let count = 1;
          let r = lastRow+dr, c = lastCol+dc;
          while (inBounds(r,c) && board[r][c]===color) { count++; r+=dr; c+=dc; }
          r = lastRow-dr; c = lastCol-dc;
          while (inBounds(r,c) && board[r][c]===color) { count++; r-=dr; c-=dc; }
          if (count >= 5) return color;
        }
        return null;
      }

      function App(){
        const [board, setBoard] = React.useState(createEmptyBoard);
        const [current, setCurrent] = React.useState('black');
        const [names] = React.useState({ black: 'æŠ€èƒ½äº”', white: 'å­ç¥º' });
        const [frozen, setFrozen] = React.useState({ black:false, white:false });
        const [skillsUsed, setSkillsUsed] = React.useState({
          black: { remove:false, freeze:false, instant:false, swap:false, add:false },
          white: { remove:false, freeze:false, instant:false, swap:false, add:false },
        });
        const [winner, setWinner] = React.useState(null);
        const [lastMove, setLastMove] = React.useState(null);
        const [skillMode, setSkillMode] = React.useState(null); // { type: 'remove'|'add'|'swap', step?:1|2, first?:{r,c} }
        const [selectedPiece, setSelectedPiece] = React.useState(null); // ç§»å½¢æ¢å½±æŠ€èƒ½é€‰ä¸­çš„æ£‹å­ä½ç½® {r, c}
        const [showRules, setShowRules] = React.useState(false);
        const toast = useToast();

        const canvasRef = React.useRef(null);
        React.useEffect(()=>{ if(canvasRef.current) drawGrid(canvasRef.current); });

        const cellSize = React.useMemo(()=>{
          const grid = document.querySelector('.grid');
          if (!grid) return 0; const rect = grid.getBoundingClientRect(); return (rect.width) / (SIZE - 1);
        }, [board]);

        const placePiece = (row,col,color) => {
          setBoard(prev => {
            if (prev[row][col]) return prev;
            const next = prev.map(r=>r.slice());
            next[row][col] = color;
            return next;
          });
          setLastMove({ row, col });
        };

        const handleBoardClick = (e) => {
          if (winner) return;
          
          // é˜²æ­¢ç§»åŠ¨ç«¯åŒé‡è§¦å‘
          e.preventDefault();
          
          const rect = e.currentTarget.getBoundingClientRect();
          const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
          const y = Math.max(0, Math.min(rect.height, e.clientY - rect.top));
          const cs = rect.width / (SIZE - 1);
          let col = Math.round(x / cs);
          let row = Math.round(y / cs);
          col = Math.max(0, Math.min(SIZE-1, col));
          row = Math.max(0, Math.min(SIZE-1, row));

          // Skill targeting mode
          if (skillMode) {
            const other = current === 'black' ? 'white' : 'black';
            if (skillMode.type === 'remove') {
              if (board[row][col] === other) {
                setBoard(prev => {
                  const next = prev.map(r=>r.slice());
                  next[row][col] = null;
                  return next;
                });
                setSkillsUsed(s => ({ ...s, [current]: { ...s[current], remove:true } }));
                setSkillMode(null);
                toast.show('æ£‹å­è¢«ä¸¢è¿›äº†ä»€åˆ¹æµ·ï¼Œä½ å¯ä»¥å†è½å­ä¸€æ¬¡');
                // é£æ²™èµ°çŸ³æŠ€èƒ½ï¼šç§»é™¤æ£‹å­åä¸åˆ‡æ¢å›åˆï¼Œå½“å‰ç©å®¶å¯ä»¥å†è½å­ä¸€æ¬¡
              }
              return;
            }
            if (skillMode.type === 'add') {
              if (!board[row][col]) {
                placePiece(row, col, current);
                setSkillsUsed(s => ({ ...s, [current]: { ...s[current], add:true } }));
                setSkillMode(null);
                toast.show('ç¥æ¥ä¹‹ç¬”å·²ä½¿ç”¨ï¼Œä½ å¯ä»¥å†è½å­ä¸€æ¬¡');
                // ç¥æ¥ä¹‹ç¬”æŠ€èƒ½ï¼šæ”¾ç½®æ£‹å­åä¸åˆ‡æ¢å›åˆï¼Œå½“å‰ç©å®¶å¯ä»¥å†è½å­ä¸€æ¬¡
              }
              return;
            }
            if (skillMode.type === 'swap') {
              if (skillMode.step === 1) {
                // ç¬¬ä¸€æ­¥ï¼šé€‰æ‹©å·±æ–¹æ£‹å­
                if (board[row][col] === current) {
                  // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»çš„æ˜¯å·²é€‰ä¸­çš„æ£‹å­
                  if (selectedPiece && selectedPiece.r === row && selectedPiece.c === col) {
                    // å–æ¶ˆé€‰ä¸­
                    setSelectedPiece(null);
                    toast.show('å·²å–æ¶ˆé€‰æ‹©ï¼Œè¯·é‡æ–°é€‰æ‹©å·±æ–¹æ£‹å­');
                  } else {
                    // é€‰ä¸­æ–°çš„æ£‹å­ï¼ˆåŒ…æ‹¬é‡æ–°é€‰æ‹©ï¼‰
                    setSkillMode({ type:'swap', step:2, first:{ r:row, c:col } });
                    setSelectedPiece({ r: row, c: col }); // è®¾ç½®é€‰ä¸­çš„æ£‹å­
                    toast.show('å·²é‡æ–°é€‰æ‹©ï¼Œç°åœ¨è¯·é€‰æ‹©å¯¹æ–¹æ£‹å­è¿›è¡Œäº¤æ¢');
                  }
                }
                return;
              } else if (skillMode.step === 2) {
                // ç¬¬äºŒæ­¥ï¼šé€‰æ‹©å¯¹æ–¹æ£‹å­è¿›è¡Œäº¤æ¢ï¼›å…è®¸å–æ¶ˆæˆ–æ”¹é€‰å·±æ–¹æ£‹å­
                // ç‚¹å‡»å·±æ–¹æ£‹å­ï¼šå–æ¶ˆæˆ–æ”¹é€‰
                if (board[row][col] === current) {
                  // ç‚¹å‡»åŒä¸€ä¸ªå·±æ–¹æ£‹å­ï¼šå–æ¶ˆé€‰ä¸­å¹¶å›åˆ°ç¬¬ä¸€æ­¥
                  if (selectedPiece && selectedPiece.r === row && selectedPiece.c === col) {
                    setSelectedPiece(null);
                    setSkillMode({ type:'swap', step:1 });
                    toast.show('å·²å–æ¶ˆé€‰æ‹©ï¼Œè¯·é‡æ–°é€‰æ‹©å·±æ–¹æ£‹å­');
                    return;
                  }
                  // ç‚¹å‡»å…¶ä»–å·±æ–¹æ£‹å­ï¼šæ”¹é€‰ä¸ºæ–°çš„å·±æ–¹æ£‹å­ï¼Œä¿æŒç¬¬äºŒæ­¥çŠ¶æ€
                  setSelectedPiece({ r: row, c: col });
                  setSkillMode({ type:'swap', step:2, first:{ r:row, c:col } });
                  toast.show('å·²é‡æ–°é€‰æ‹©ï¼Œç°åœ¨è¯·é€‰æ‹©å¯¹æ–¹æ£‹å­è¿›è¡Œäº¤æ¢');
                  return;
                }

                // ç‚¹å‡»å¯¹æ–¹æ£‹å­ï¼šæ‰§è¡Œäº¤æ¢
                if (board[row][col] === other) {
                  const a = skillMode.first;
                  setBoard(prev => {
                    const next = prev.map(r=>r.slice());
                    next[a.r][a.c] = other;
                    next[row][col] = current;
                    return next;
                  });
                  setSkillsUsed(s => ({ ...s, [current]: { ...s[current], swap:true } }));
                  setSkillMode(null);
                  setSelectedPiece(null); // æ¸…é™¤é€‰ä¸­çŠ¶æ€
                  toast.show('ç§»å½¢æ¢å½±å·²å®Œæˆï¼Œä½ å¯ä»¥å†è½å­ä¸€æ¬¡');
                  // ç§»å½¢æ¢å½±æŠ€èƒ½ï¼šäº¤æ¢å®Œæˆåä¸åˆ‡æ¢å›åˆï¼Œå½“å‰ç©å®¶å¯ä»¥å†è½å­ä¸€æ¬¡
                }
                return;
              }
            }
          }

          // Freeze skip check
          if (frozen[current]) {
            setFrozen(prev => ({ ...prev, [current]: false }));
            setCurrent(c => c === 'black' ? 'white' : 'black');
            return;
          }

          // Normal placement
          if (board[row][col] || winner) return; // å¦‚æœä½ç½®å·²å ç”¨æˆ–æ¸¸æˆç»“æŸï¼Œç›´æ¥è¿”å›
          
          setBoard(prev => {
            const next = prev.map(r=>r.slice());
            next[row][col] = current;
            return next;
          });
          setLastMove({ row, col });
          const nextTurn = current === 'black' ? 'white' : 'black';
          if (frozen[nextTurn]) {
            // auto-skip opponent: clear freeze and keep current turn
            setFrozen(prev => ({ ...prev, [nextTurn]: false }));
            // ä¿æŒå½“å‰ç©å®¶ç»§ç»­ä¸‹æ£‹ï¼Œä¸åˆ‡æ¢
          } else {
            setCurrent(nextTurn);
          }
        };

        React.useEffect(()=>{
          if (lastMove) {
            const w = calcWin(board, lastMove.row, lastMove.col);
            if (w) setWinner(w);
          }
        }, [board, lastMove]);

        React.useEffect(()=>{
          if (winner) {
            const name = winner === 'black' ? names.black : names.white;
            toast.show(`${name} è·èƒœï¼æ­å–œè¿æˆäº”å­ï¼`);
          }
        }, [winner]);

        const reset = () => {
          setBoard(createEmptyBoard());
          setCurrent('black');
          setFrozen({ black:false, white:false });
          setSkillsUsed({ black: { remove:false, freeze:false, instant:false, swap:false, add:false }, white: { remove:false, freeze:false, instant:false, swap:false, add:false } });
          setWinner(null);
          setLastMove(null);
          setSkillMode(null);
          setSelectedPiece(null);
        };

        // Skills
        const useRemove = () => {
          if (winner) return;
          if (skillsUsed[current].remove) return;
          setSkillMode({ type:'remove' });
          setSelectedPiece(null); // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
          toast.show('è¯·é€‰æ‹©è¦ç§»é™¤çš„å¯¹æ‰‹æ£‹å­');
        };

        const useFreeze = () => {
          if (winner) return;
          if (skillsUsed[current].freeze) return;
          const other = current === 'black' ? 'white' : 'black';
          setFrozen(prev => ({ ...prev, [other]: true }));
          setSkillsUsed(s => ({ ...s, [current]: { ...s[current], freeze:true } }));
        };

        const useInstant = () => {
          if (winner) return;
          if (skillsUsed[current].instant) return;
          setSkillsUsed(s => ({ ...s, [current]: { ...s[current], instant:true } }));
          setWinner(current);
        };

        const useSwap = () => {
          if (winner) return;
          if (skillsUsed[current].swap) return;
          setSkillMode({ type:'swap', step:1 });
          setSelectedPiece(null); // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
          toast.show('è¯·é€‰æ‹©å·±æ–¹æ£‹å­ï¼ˆå¯é‡æ–°é€‰æ‹©æˆ–ç‚¹å‡»å·²é€‰ä¸­æ£‹å­å–æ¶ˆï¼‰');
        };

        const useAdd = () => {
          if (winner) return;
          if (skillsUsed[current].add) return;
          setSkillMode({ type:'add' });
          setSelectedPiece(null); // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
          toast.show('é€‰æ‹©ä»»æ„ä½ç½®æ”¾ç½®ä¸€å­');
        };

        const pieces = [];
        const gridRect = document.querySelector('.grid')?.getBoundingClientRect();
        const cs = gridRect ? (gridRect.width) / (SIZE - 1) : 0;

        for (let r=0;r<SIZE;r++) {
          for (let c=0;c<SIZE;c++) {
            const v = board[r][c];
            if (!v) continue;
            const x = c * cs;
            const y = r * cs;
            const isSelected = selectedPiece && selectedPiece.r === r && selectedPiece.c === c;
            pieces.push(
              <div key={`${r}-${c}`} className="piece" style={{ left: x, top: y }}>
                <div className={`stone ${v}${isSelected ? ' selected' : ''}`} />
              </div>
            );
          }
        }

        const skillsPanel = (
          <div className="skill-grid">
            <div className="skill-card">
              <h4>é£æ²™èµ°çŸ³</h4>
              <p className="count">å‰©ä½™ï¼š{skillsUsed[current].remove ? 0 : 1}</p>
              <button className="btn danger" disabled={skillsUsed[current].remove || !!winner} onClick={useRemove}>ç§»é™¤å¯¹æ‰‹ä»»æ„ä¸€æšæ£‹å­</button>
            </div>
            <div className="skill-card">
              <h4>é™å¦‚æ­¢æ°´</h4>
              <p className="count">å‰©ä½™ï¼š{skillsUsed[current].freeze ? 0 : 1}</p>
              <button className="btn accent" disabled={skillsUsed[current].freeze || !!winner} onClick={useFreeze}>å†»ç»“å¯¹æ–¹ä¸€å›åˆ</button>
            </div>
            <div className="skill-card">
              <h4>åŠ›æ‹”å±±å…®</h4>
              <p className="count">å‰©ä½™ï¼š{skillsUsed[current].instant ? 0 : 1}</p>
              <button className="btn success" disabled={skillsUsed[current].instant || !!winner} onClick={useInstant}>ç»ˆææŠ€èƒ½ï¼šç›´æ¥è·å¾—èƒœåˆ©</button>
            </div>
            <div className="skill-card">
              <h4>ç§»å½¢æ¢å½±</h4>
              <p className="count">å‰©ä½™ï¼š{skillsUsed[current].swap ? 0 : 1}</p>
              <button className="btn" disabled={skillsUsed[current].swap || !!winner} onClick={useSwap}>äº¤æ¢åŒæ–¹ä¸€æšæ£‹å­</button>
            </div>
            <div className="skill-card">
              <h4>ç¥æ¥ä¹‹ç¬”</h4>
              <p className="count">å‰©ä½™ï¼š{skillsUsed[current].add ? 0 : 1}</p>
              <button className="btn" disabled={skillsUsed[current].add || !!winner} onClick={useAdd}>åœ¨ä»»æ„ä½ç½®æ”¾ç½®ä¸€å­</button>
            </div>
          </div>
        );

        return (
          <div className="container">
            <div className="card">
              <div className="header">
                <div className="title">
                  <span>æŠ€èƒ½äº” vs å­ç¥º</span>
                  <span className="badge black">é»‘ï¼šæŠ€èƒ½äº”</span>
                  <span className="badge white">ç™½ï¼šå­ç¥º</span>
                </div>
                <div className="row">
                  <button className="btn" onClick={()=>setShowRules(true)}>è§„åˆ™è¯´æ˜</button>
                  <button className="btn" onClick={reset}>é‡æ–°å¼€å§‹</button>
                </div>
              </div>
              {/* å¤§å­—æŠ¥æ ·å¼çš„å½“å‰ç©å®¶æ˜¾ç¤º */}
              <div className="current-player-banner">
                {winner ? (
                  <div className="winner-banner">
                    ğŸ‰ èƒœè€…ï¼š{winner === 'black' ? names.black : names.white} ğŸ‰
                  </div>
                ) : (
                  <div className="player-turn">
                    è½®åˆ°ï¼š{current === 'black' ? `${names.black}ï¼ˆé»‘æ£‹ï¼‰` : `${names.white}ï¼ˆç™½æ£‹ï¼‰`}
                    {frozen[current] && <span className="frozen-notice">ï¼ˆæœ¬å›åˆå†»ç»“ï¼Œè‡ªåŠ¨è·³è¿‡ï¼‰</span>}
                  </div>
                )}
              </div>
              
              <div className="board-wrap">
                <div className="board">
                  <div className="grid" onClick={handleBoardClick}>
                    <canvas ref={canvasRef}/>
                  </div>
                  <div className="hint">
                    {starPoints.map(([r,c]) => {
                      const x = c * cs; const y = r * cs;
                      return <div key={`star-${r}-${c}`} className="hint-dot" style={{ left: x, top: y }} />
                    })}
                  </div>
                  <div className="pieces">{pieces}</div>
                </div>
              </div>
              <div className="footer">
                <div className="status">æœ€è¿‘è½å­ï¼š{lastMove ? `${lastMove.row+1}, ${lastMove.col+1}` : '-'}</div>
              </div>
            </div>

            <div className="card">
              <div className="panel">
                <h3>æŠ€èƒ½é¢æ¿</h3>
                <p className="status">æ¯ç§æŠ€èƒ½æ¯å±€ä»…å¯ä½¿ç”¨ä¸€æ¬¡ã€‚å½“å‰ç©å®¶ï¼š{current==='black'?names.black:names.white}</p>
                {skillsPanel}
              </div>
            </div>

            {showRules && (
              <div className="modal-backdrop" onClick={()=>setShowRules(false)}>
                <div className="modal" onClick={(e)=>e.stopPropagation()}>
                  <div className="header">
                    <div className="title">äº”å­æ£‹è§„åˆ™è¯´æ˜</div>
                    <button className="btn" onClick={()=>setShowRules(false)}>å…³é—­</button>
                  </div>
                  <div className="content">
                    <p>1. æ£‹ç›˜ä¸º15Ã—15ï¼ŒåŒæ–¹è½®æµåœ¨ç©ºä½å¤„è½å­ï¼Œç‡å…ˆå½¢æˆä»»æ„æ–¹å‘è¿ç»­äº”å­è€…è·èƒœã€‚</p>
                    <p>2. æ˜Ÿä½ä»…ä¸ºè§†è§‰å‚è€ƒï¼Œå¯åœ¨æ˜Ÿä½ä¸Šè½å­ã€‚</p>
                    <p>3. æŠ€èƒ½ç³»ç»Ÿï¼ˆæ¯ç§æ¯å±€ä¸€æ¬¡ï¼‰ï¼š</p>
                    <ul>
                      <li>é£æ²™èµ°çŸ³ï¼šç§»é™¤å¯¹æ‰‹ä»»æ„ä¸€æšæ£‹å­ã€‚</li>
                      <li>é™å¦‚æ­¢æ°´ï¼šå†»ç»“å¯¹æ–¹ä¸€å›åˆï¼Œå·±æ–¹å¯è¿ç»­ä¸‹ä¸¤æ­¥ï¼ˆé€šè¿‡è·³è¿‡å¯¹æ–¹å›åˆå®ç°ï¼‰ã€‚</li>
                      <li>åŠ›æ‹”å±±å…®ï¼šç»ˆææŠ€èƒ½ï¼Œç›´æ¥è·å¾—èƒœåˆ©ã€‚</li>
                      <li>ç§»å½¢æ¢å½±ï¼šäº¤æ¢åŒæ–¹å„ä¸€æšå·²è½å­ã€‚</li>
                      <li>ç¥æ¥ä¹‹ç¬”ï¼šåœ¨ä»»æ„ä½ç½®é¢å¤–æ”¾ç½®ä¸€å­ã€‚</li>
                    </ul>
                    <p>4. åœ¨ç§»åŠ¨ç«¯ï¼Œæ£‹ç›˜ä¸é¢æ¿ä¼šè‡ªé€‚åº”å¸ƒå±€ã€‚</p>
                  </div>
                </div>
              </div>
            )}

            {winner && (
              <div className="modal-backdrop" onClick={()=>{}}>
                <div className="modal" onClick={(e)=>e.stopPropagation()}>
                  <div className="header">
                    <div className="title">æ¸¸æˆç»“æŸ</div>
                    <button className="btn" onClick={reset}>é‡æ–°å¼€å§‹</button>
                  </div>
                  <div className="content">
                    <h3 style={{marginTop:0}}>èƒœè€…ï¼š{winner === 'black' ? names.black : names.white}</h3>
                    <p>æ­å–œè¾¾æˆè¿ç»­äº”å­ï¼å¯ç‚¹å‡»å³ä¸Šè§’â€œé‡æ–°å¼€å§‹â€å†æˆ˜ä¸€å±€ã€‚</p>
                  </div>
                </div>
              </div>
            )}

            {toast.msg && <div className="toast">{toast.msg}</div>}
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App/>);
    </script>
  </body>
  </html>