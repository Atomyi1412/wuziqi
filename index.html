<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æŠ€èƒ½äº” vs å­ç¥º - äº”å­æ£‹å¯¹æˆ˜</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css" />
    <style>
      :root {
        --bg-gradient: radial-gradient(1400px 900px at 20% 0%, #f5f7fb, #eef2f7 55%, #e9edf5);
        --surface: #ffffff;
        --card-bg: #ffffff;
        --card-border: rgba(15,23,42,0.12);
        --accent: #0f172a;
        --accent-2: #06b6d4;
        --win: #22c55e;
        --lose: #ef4444;
        --text: #0f172a;
        --muted: #475569;
        --grid: #cbd5e1;
        --black: #0f172a;
        --white: #e5e7eb;
        --shadow: 0 12px 30px rgba(0,0,0,0.12);
      }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: Inter, -apple-system, system-ui, Segoe UI, Roboto, Ubuntu, Cantarell, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--text);
        background: var(--bg-gradient);
        min-height: 100vh;
        display: grid;
        place-items: center;
        overflow-x: hidden;
        /* å…¨å±€ç§»åŠ¨ç«¯è§¦æ‘¸ä¼˜åŒ– */
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        touch-action: manipulation;
      }
      .container {
        width: min(1200px, 95vw);
        display: grid;
        grid-template-columns: 1fr 360px;
        gap: 20px;
      }
      .container.start { grid-template-columns: 1fr; width: min(980px, 95vw); }
      .container.normal { grid-template-columns: 1fr; }
      @media (max-width: 980px) {
        .container { grid-template-columns: 1fr; }
      }
      .card {
        background: var(--card-bg);
        border: 1px solid var(--card-border);
        border-radius: 16px;
        box-shadow: var(--shadow);
      }
      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        border-bottom: 1px solid var(--card-border);
      }
      .header .left { display: flex; align-items: center; gap: 12px; }
      .icon-btn { display:inline-flex; align-items:center; justify-content:center; width:36px; height:36px; border-radius:999px; border:1px solid var(--card-border); background: #ffffff; color: var(--text); cursor:pointer; transition: background .2s ease, border-color .2s ease, transform .1s ease, color .2s ease; }
      .icon-btn svg { width:20px; height:20px; }
      .icon-btn:hover { background: rgba(15,23,42,0.06); color: var(--text); border-color: var(--card-border); }
      .icon-btn:active { transform: translateY(1px); }
      .icon-btn:focus-visible { outline: none; box-shadow: 0 0 0 2px rgba(15,23,42,0.18); }
      .title {
        font-weight: 700;
        letter-spacing: 0.5px;
        display: flex; gap: 10px; align-items: center;
        color: var(--text);
        background: none;
        -webkit-text-fill-color: var(--text);
      }
      .badge { padding: 6px 10px; border-radius: 999px; font-size: 12px; color: var(--text); background: #f8fafc; border: 1px solid var(--card-border); }
      .badge.black { background: #f8fafc; }
      .badge.white { background: #f8fafc; }
      .board-wrap { padding: 20px; }
      .board {
        aspect-ratio: 1 / 1;
        max-width: 740px;
        width: 100%;
        margin: 0 auto;
        background: linear-gradient(180deg, #f1e4c8, #e0c991);
        border-radius: 16px;
        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.12), var(--shadow);
        position: relative;
        overflow: hidden;
        /* ç§»åŠ¨ç«¯è§¦æ‘¸ä¼˜åŒ– */
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        touch-action: manipulation;
      }
      @media (max-width: 768px) {
        .board {
          max-width: 90vw;
          border-radius: 8px;
        }
      }
      .grid { 
        position: absolute; 
        inset: 16px; 
        cursor: pointer; 
        z-index: 1;
        /* é˜²æ­¢ç§»åŠ¨ç«¯è§¦æ‘¸é«˜äº®å’Œé®ç½©é—ªçƒ */
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        touch-action: manipulation;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        outline: none;
        border: none;
        background: transparent;
      }
      .grid canvas { width: 100%; height: 100%; display: block; pointer-events: none; }
      /* æŒ‰é’®ï¼ˆè‹¹æœé£ï¼‰ */
      .btn { padding:10px 14px; border-radius:12px; border:1px solid var(--card-border); background:#ffffff; color: var(--text); cursor:pointer; transition: .2s ease; }
      .btn:hover { transform: translateY(-1px); filter: brightness(1.04); }
      .btn:active { transform: translateY(0); }
      /* ç»Ÿä¸€å˜ä½“æŒ‰é’®ä¸ºä¸­æ€§æµ…è‰²ï¼Œé¿å…å¤šå½©åˆ†æ•£ */
      .btn.accent, .btn.success, .btn.danger { background: #ffffff; color: var(--text); border-color: var(--card-border); }
      /* ç»Ÿä¸€æŠ€èƒ½è¯´æ˜æŒ‰é’®é¢œè‰²ï¼ˆæŸ”å’Œä¸­æ€§ï¼‰ */
      .btn.skill { background: #f8fafc; color: var(--text); border-color: #e2e8f0; }
      .btn.skill:hover { filter: brightness(1.05); }
      
      /* ç§»åŠ¨ç«¯ä¸“ç”¨è§¦æ‘¸ä¼˜åŒ– */
      @media (hover: none) and (pointer: coarse) {
        * {
          -webkit-tap-highlight-color: transparent !important;
          -webkit-touch-callout: none !important;
          -webkit-user-select: none !important;
          user-select: none !important;
        }
        .board, .grid, .board * {
          -webkit-tap-highlight-color: transparent !important;
          -webkit-touch-callout: none !important;
          touch-action: manipulation !important;
          -webkit-appearance: none !important;
          outline: none !important;
        }
        .btn:active, .icon-btn:active {
          transform: none !important;
        }
      }
      
      /* æ¨¡å¼é€‰æ‹©å¡ç‰‡ç•™ç™½ */
      .start-wrap .mode-choices { display:grid; grid-template-columns: 1fr 1fr; gap: 16px; }
      .start-wrap .mode-card { background: var(--card-bg); border:1px solid var(--card-border); border-radius:16px; padding: 16px; box-shadow: var(--shadow); }
      .start-wrap .desc { color: var(--muted); }
      .pieces { position: absolute; inset: 16px; pointer-events: none; z-index: 3; }
      .piece {
        position: absolute;
        width: 28px; height: 28px;
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 3;
      }
      @media (max-width: 768px) {
        .piece {
          width: 20px; height: 20px;
        }
      }
      @media (max-width: 480px) {
        .piece {
          width: 16px; height: 16px;
        }
      }
      .stone {
        width: 100%; height: 100%;
        border-radius: 50%;
        box-shadow: 0 8px 18px rgba(0,0,0,0.28), inset 0 -3px 7px rgba(0,0,0,0.28), inset 0 4px 10px rgba(255,255,255,0.35);
        transition: transform 0.18s ease, box-shadow 0.2s ease;
        border: 1px solid rgba(0,0,0,0.25);
      }
      .stone.black { background: radial-gradient(circle at 35% 30%, #374151, #0b0f1a 70%); }
      .stone.white { background: radial-gradient(circle at 40% 35%, #f3f4f6, #cbd5e1 70%); }
      
      /* ç§»å½¢æ¢å½±æŠ€èƒ½é€‰ä¸­æ•ˆæœ */
      .stone.selected {
        box-shadow: 
          0 0 0 3px var(--accent),
          0 0 0 6px rgba(124, 58, 237, 0.3),
          0 8px 18px rgba(0,0,0,0.35), 
          inset 0 -4px 8px rgba(0,0,0,0.35), 
          inset 0 4px 10px rgba(255,255,255,0.35);
        transform: scale(1.1);
        animation: selectedPulse 1.5s ease-in-out infinite;
      }
      
      @keyframes selectedPulse {
        0%, 100% { 
          box-shadow: 
            0 0 0 3px var(--accent),
            0 0 0 6px rgba(124, 58, 237, 0.3),
            0 8px 18px rgba(0,0,0,0.35), 
            inset 0 -4px 8px rgba(0,0,0,0.35), 
            inset 0 4px 10px rgba(255,255,255,0.35);
        }
        50% { 
          box-shadow: 
            0 0 0 4px var(--accent),
            0 0 0 8px rgba(124, 58, 237, 0.5),
            0 8px 18px rgba(0,0,0,0.35), 
            inset 0 -4px 8px rgba(0,0,0,0.35), 
            inset 0 4px 10px rgba(255,255,255,0.35);
        }
      }
      .hint { position: absolute; inset: 16px; pointer-events: none; z-index: 2; }
      .hint-dot {
        position: absolute; width: 10px; height: 10px; border-radius: 50%;
        background: rgba(0,0,0,0.35);
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      @media (max-width: 768px) {
        .hint-dot {
          width: 8px; height: 8px;
        }
      }
      @media (max-width: 480px) {
        .hint-dot {
          width: 6px; height: 6px;
        }
      }
      .controls { padding: 16px; display: grid; gap: 12px; }
      .row { display: flex; gap: 10px; align-items: center; justify-content: space-between; }
      .btn {
        padding: 10px 14px;
        border-radius: 12px;
        border: 1px solid var(--card-border);
        background: #ffffff;
        color: var(--text);
        cursor: pointer;
        transition: transform .18s ease, filter .18s ease;
        font-weight: 600;
        letter-spacing: .2px;
      }
      .btn:hover { transform: translateY(-1px); filter: brightness(1.04); }
      .btn:disabled { opacity: .45; cursor: not-allowed; }
      .btn.accent, .btn.danger, .btn.success { background: #ffffff; color: var(--text); border-color: var(--card-border); }
      .panel { padding: 16px; }
      .status { font-family: JetBrains Mono, monospace; color: var(--muted); font-size: 13px; }
      .skill-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
      .skill-card { padding: 12px; border-radius: 12px; border: 1px solid var(--card-border); background: #ffffff; }
      .skill-card h4 { margin: 6px 0; font-size: 14px; }
      .count { font-size: 12px; color: var(--muted); }
      .footer { padding: 10px 16px; border-top: 1px solid var(--card-border); display: flex; justify-content: space-between; align-items: center; }
      .link { color: #0ea5e9; text-decoration: none; }
      .modal-backdrop { position: fixed; inset: 0; background: rgba(15,23,42,1); display: grid; place-items: center; z-index: 9998; }
      .modal { width: min(720px, 92vw); background: #ffffff; border: 1px solid var(--card-border); border-radius: 18px; box-shadow: var(--shadow); z-index: 9999; }
      .modal .content { padding: 16px 18px; }
      .modal h3 { margin: 0; }
      .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,.7); color: #fff; padding: 10px 14px; border-radius: 999px; box-shadow: var(--shadow); }
      /* å¼€å§‹ç•Œé¢æ ·å¼ */
      .start-wrap { max-width: 980px; margin: 48px auto; padding: 20px; }
      .mode-choices { display: grid; grid-template-columns: repeat(2, 1fr); gap: 18px; align-items: stretch; }
      .mode-card { padding: 18px; border-radius: 16px; border: 1px solid var(--card-border); background: #ffffff; box-shadow: var(--shadow); display: flex; flex-direction: column; min-height: 220px; }
      .mode-card h3 { margin: 0 0 8px 0; }
      .mode-card .desc { color: var(--muted); font-size: 14px; margin-bottom: 12px; }
      .mode-card .actions { margin-top: auto; display: flex; gap: 10px; }
      .form { padding: 18px; border-radius: 16px; border: 1px dashed var(--card-border); }
      .form-row { display:flex; align-items:center; gap:10px; margin-bottom:10px; }
      .form-row input[type="text"] { flex:1; padding:8px 10px; border-radius:10px; border:1px solid var(--card-border); background: rgba(255,255,255,0.06); color: var(--text); }
      .form-row input[type="color"] { width:42px; height:32px; padding:0; border:none; background: transparent; }
      /* æ•°å­—è¾“å…¥éšè—ä¸Šä¸‹ç®­å¤´ï¼Œæ”¯æŒç›´æ¥è¾“å…¥ */
      .form-row input[type="number"] { width: 90px; padding:8px 10px; border-radius:10px; border:1px solid var(--card-border); background:#ffffff; color: var(--text); appearance: textfield; -moz-appearance: textfield; }
      .form-row input[type="number"]::-webkit-outer-spin-button,
      .form-row input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
      .color-dot { display:inline-block; width:12px; height:12px; border-radius:999px; margin-left:8px; border:1px solid rgba(255,255,255,0.35); vertical-align:middle; }
      
      /* å½“å‰ç©å®¶æ¨ªå¹…ï¼ˆæŸ”å’Œè‹¹æœé£ï¼‰ */
      .current-player-banner {
        text-align: center;
        margin: 20px 0;
        padding: 16px 24px;
        background: #ffffff;
        border: 1px solid var(--card-border);
        border-radius: 16px;
        box-shadow: var(--shadow);
      }
      .player-turn {
        font-size: 22px;
        font-weight: 700;
        color: var(--text);
        letter-spacing: .5px;
      }
      .winner-banner {
        font-size: 24px;
        font-weight: 800;
        color: var(--accent);
        letter-spacing: 1px;
      }
      .frozen-notice {
        display: block;
        font-size: 14px;
        color: var(--muted);
        margin-top: 6px;
        font-weight: 500;
      }
      
      @keyframes playerTurnPulse {
        0%, 100% { 
          transform: scale(1);
          text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }
        50% { 
          transform: scale(1.02);
          text-shadow: 0 4px 16px rgba(124, 58, 237, 0.4);
        }
      }
      
      @keyframes winnerGlow {
        0% { 
          text-shadow: 0 2px 12px rgba(251, 191, 36, 0.6);
        }
        100% { 
          text-shadow: 0 4px 24px rgba(251, 191, 36, 0.9), 0 0 40px rgba(251, 191, 36, 0.3);
        }
      }
      
      /* å“åº”å¼è®¾è®¡ */
      @media (max-width: 768px) {
        .mode-choices { grid-template-columns: 1fr; }
        .current-player-banner {
          margin: 16px 0;
          padding: 12px 16px;
        }
        
        .player-turn { font-size: 20px; }
        .winner-banner { font-size: 22px; }
        .frozen-notice { font-size: 13px; }
      }
      
      @media (max-width: 480px) {
        .player-turn {
          font-size: 18px;
        }
        
        .winner-banner {
          font-size: 20px;
        }
        
        .frozen-notice {
          font-size: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel" data-type="module" data-presets="env,react">
      const SIZE = 15;

      const createEmptyBoard = () => Array.from({ length: SIZE }, () => Array(SIZE).fill(null));

      const starPoints = [
        [3,3],[3,11],[11,3],[11,11],[7,7]
      ];

      function useToast() {
        const [msg, setMsg] = React.useState(null);
        const show = React.useCallback((text) => {
          setMsg(text);
          setTimeout(() => setMsg(null), 1800);
        }, []);
        return { msg, show };
      }

      function drawGrid(canvas) {
        const dpr = window.devicePixelRatio || 1;
        // ä½¿ç”¨å¸ƒå±€å°ºå¯¸ï¼Œé¿å… CSS transform å½±å“è®¡ç®—
        const baseW = canvas.offsetWidth;
        const baseH = canvas.offsetHeight;
        canvas.width = Math.max(1, Math.floor(baseW * dpr));
        canvas.height = Math.max(1, Math.floor(baseH * dpr));
        const ctx = canvas.getContext('2d');
        ctx.setTransform(1,0,0,1,0,0);
        ctx.scale(dpr, dpr);
        ctx.clearRect(0,0,baseW, baseH);
        ctx.strokeStyle = '#2b3547';
        ctx.lineWidth = 1;
        const padding = 0;
        const cellSize = (baseW) / (SIZE - 1);
        for (let i = 0; i < SIZE; i++) {
          const pos = padding + i * cellSize;
          ctx.beginPath(); ctx.moveTo(padding, pos); ctx.lineTo(baseW - padding, pos); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(pos, padding); ctx.lineTo(pos, baseH - padding); ctx.stroke();
        }
        // star points
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        starPoints.forEach(([r,c]) => {
          const x = padding + c * cellSize;
          const y = padding + r * cellSize;
          ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fill();
        });
      }

      function calcWin(board, lastRow, lastCol) {
        if (lastRow == null || lastCol == null) return null;
        const color = board[lastRow][lastCol];
        if (color == null) return null;
        const dirs = [[1,0],[0,1],[1,1],[1,-1]];
        const inBounds = (r,c)=> r>=0 && r<SIZE && c>=0 && c<SIZE;
        for (const [dr,dc] of dirs) {
          let count = 1;
          let r = lastRow+dr, c = lastCol+dc;
          while (inBounds(r,c) && board[r][c]===color) { count++; r+=dr; c+=dc; }
          r = lastRow-dr; c = lastCol-dc;
          while (inBounds(r,c) && board[r][c]===color) { count++; r-=dr; c-=dc; }
          if (count >= 5) return color;
        }
        return null;
      }

      function App(){
        const [gameMode, setGameMode] = React.useState(null); // null -> start, 'skill' | 'normal'
        const [players, setPlayers] = React.useState([]); // æ™®é€šæ¨¡å¼ç©å®¶æ•°ç»„ {id,name,color}
        const [currentIndex, setCurrentIndex] = React.useState(0);
        const defaultColors = ['#111827','#f3f4f6','#e11d48','#2563eb','#10b981','#f59e0b','#8b5cf6','#0ea5e9'];
        const [normalConfig, setNormalConfig] = React.useState({
          count: 2,
          players: [
            { name:'ç©å®¶1', color:'#111827', type:'human', difficulty:'easy' },
            { name:'ç©å®¶2', color:'#f3f4f6', type:'human', difficulty:'easy' }
          ]
        });
        const [showNormalConfig, setShowNormalConfig] = React.useState(false);
        const ensureConfigCount = React.useCallback((n)=>{
          setNormalConfig(prev=>{
            let arr = prev.players.slice(0, n);
            while(arr.length < n){
              const i = arr.length;
              arr.push({ name:`ç©å®¶${i+1}`, color: defaultColors[i % defaultColors.length], type:'human', difficulty:'easy' });
            }
            return { ...prev, count:n, players: arr };
          });
        },[]);

        // å…è®¸æŠŠé»˜è®¤çš„â€œ2â€åˆ é™¤åå†è¾“å…¥æ–°æ•°å­—ï¼›å¤±ç„¦æ—¶å†æ ¡æ­£åˆ° â‰¥2
        const handleCountChange = React.useCallback((e)=>{
          const v = e.target.value;
          if (v === '') { // è¾“å…¥ä¸ºç©ºæ—¶ï¼Œæš‚ä¸å¼ºåˆ¶å›å¡«ï¼Œä¾¿äºæ›¿æ¢è¾“å…¥
            setNormalConfig(prev => ({ ...prev, count: '' }));
            return;
          }
          const n = Number(v);
          if (Number.isNaN(n)) return;
          ensureConfigCount(Math.max(2, n));
        }, [ensureConfigCount]);

        const [board, setBoard] = React.useState(createEmptyBoard);
        const [current, setCurrent] = React.useState('black');
        const [names] = React.useState({ black: 'æŠ€èƒ½äº”', white: 'å­ç¥º' });
        const [frozen, setFrozen] = React.useState({ black:false, white:false });
        const [skillsUsed, setSkillsUsed] = React.useState({
          black: { remove:false, freeze:false, instant:false, swap:false, add:false },
          white: { remove:false, freeze:false, instant:false, swap:false, add:false },
        });
        const [winner, setWinner] = React.useState(null);
        const [lastMove, setLastMove] = React.useState(null);
        const [aiThinking, setAiThinking] = React.useState(false);
        const [skillMode, setSkillMode] = React.useState(null); // { type: 'remove'|'add'|'swap', step?:1|2, first?:{r,c} }
        const [selectedPiece, setSelectedPiece] = React.useState(null); // ç§»å½¢æ¢å½±æŠ€èƒ½é€‰ä¸­çš„æ£‹å­ä½ç½® {r, c}
        const [showRules, setShowRules] = React.useState(false);
        // æ‹–åŠ¨ä¸ç¼©æ”¾çŠ¶æ€
        const [panMode, setPanMode] = React.useState(false);
        const [dragging, setDragging] = React.useState(false);
        const dragOriginRef = React.useRef(null);
        const [pan, setPan] = React.useState({ x: 0, y: 0 });
        const [zoom, setZoom] = React.useState(1);
        const toast = useToast();

        const canvasRef = React.useRef(null);
        React.useEffect(()=>{ if(canvasRef.current) drawGrid(canvasRef.current); });

        const cellSize = React.useMemo(()=>{
          const grid = document.querySelector('.grid');
          if (!grid) return 0; const rect = grid.getBoundingClientRect(); return (rect.width) / (SIZE - 1);
        }, [board]);

        const placePiece = (row,col,color) => {
          setBoard(prev => {
            if (prev[row][col]) return prev;
            const next = prev.map(r=>r.slice());
            next[row][col] = color;
            return next;
          });
          setLastMove({ row, col });
        };

        // ===== æ™®é€šæ¨¡å¼ AI é€»è¾‘ä¸è¾…åŠ©å‡½æ•° =====
        const inBoundsN = (r,c)=> r>=0 && r<SIZE && c>=0 && c<SIZE;
        function wouldWinAtN(board, r, c, pid){
          if (board[r][c] != null) return false;
          const dirs = [[1,0],[0,1],[1,1],[1,-1]];
          for (const [dr,dc] of dirs){
            let count = 1;
            let rr=r+dr, cc=c+dc;
            while(inBoundsN(rr,cc) && board[rr][cc]===pid){ count++; rr+=dr; cc+=dc; }
            rr=r-dr; cc=c-dc;
            while(inBoundsN(rr,cc) && board[rr][cc]===pid){ count++; rr-=dr; cc-=dc; }
            if (count>=5) return true;
          }
          return false;
        }

        function listEmptyN(board){
          const cells=[];
          for(let r=0;r<SIZE;r++){
            for(let c=0;c<SIZE;c++){
              if(board[r][c]==null) cells.push([r,c]);
            }
          }
          return cells;
        }

        function hasNeighbourN(board, r, c){
          for(let dr=-1;dr<=1;dr++){
            for(let dc=-1;dc<=1;dc++){
              if(dr===0 && dc===0) continue;
              const rr=r+dr, cc=c+dc;
              if(inBoundsN(rr,cc) && board[rr][cc]!=null) return true;
            }
          }
          return false;
        }

        function scoreCellN(board, r, c, pid){
          const dirs=[[1,0],[0,1],[1,1],[1,-1]];
          const opponents = players.map(p=>p.id).filter(id=>id!==pid);
          let selfBest=0, oppBest=0;
          for(const [dr,dc] of dirs){
            let self=1, rr=r+dr, cc=c+dc;
            while(inBoundsN(rr,cc) && board[rr][cc]===pid){ self++; rr+=dr; cc+=dc; }
            rr=r-dr; cc=c-dc;
            while(inBoundsN(rr,cc) && board[rr][cc]===pid){ self++; rr-=dr; cc-=dc; }
            selfBest=Math.max(selfBest,self);
            let oppDirBest=0;
            for(const oid of opponents){
              let opp=1; rr=r+dr; cc=c+dc;
              while(inBoundsN(rr,cc) && board[rr][cc]===oid){ opp++; rr+=dr; cc+=dc; }
              rr=r-dr; cc=c-dc;
              while(inBoundsN(rr,cc) && board[rr][cc]===oid){ opp++; rr-=dr; cc-=dc; }
              oppDirBest=Math.max(oppDirBest, opp);
            }
            oppBest=Math.max(oppBest, oppDirBest);
          }
          const centerBias = (Math.abs(r-(SIZE/2)) + Math.abs(c-(SIZE/2)));
          const centerScore = 8 - Math.min(8, centerBias);
          return (selfBest*selfBest*2) + (oppBest*oppBest) + centerScore + (hasNeighbourN(board,r,c)?5:0);
        }

        function chooseAIMove(board, pid, difficulty){
          const empties=listEmptyN(board);
          if(empties.length===0) return null;
          for(const [r,c] of empties){ if(wouldWinAtN(board,r,c,pid)) return {r,c}; }
          const opponents = players.map(p=>p.id).filter(id=>id!==pid);
          for(const [r,c] of empties){
            for(const oid of opponents){ if(wouldWinAtN(board,r,c,oid)) return {r,c}; }
          }
          if(difficulty==='easy'){
            const near=empties.filter(([r,c])=>hasNeighbourN(board,r,c));
            const pool = near.length>0?near:empties;
            const [r,c]=pool[Math.floor(Math.random()*pool.length)];
            return {r,c};
          }
          if(difficulty==='medium'){
            let best=null, bestScore=-Infinity;
            for(const [r,c] of empties){
              const s=scoreCellN(board,r,c,pid);
              if(s>bestScore){ bestScore=s; best={r,c}; }
            }
            return best;
          }
          let bests=[]; let bestScore=-Infinity;
          for(const [r,c] of empties){
            const s=scoreCellN(board,r,c,pid);
            if(s>bestScore){ bestScore=s; bests=[{r,c}]; }
            else if(s===bestScore){ bests.push({r,c}); }
          }
          if(bests.length===1) return bests[0];
          const near=bests.filter(m=>hasNeighbourN(board,m.r,m.c));
          return (near[0]||bests[0]);
        }

        function placeNormalAt(r,c,pid){
          setBoard(prev=>{
            const next=prev.map(row=>row.slice());
            next[r][c]=pid;
            return next;
          });
          setLastMove({ r, c });
          setCurrentIndex(i => (i + 1) % players.length);
        }

        // æ£‹ç›˜æ‹–åŠ¨äº‹ä»¶å¤„ç†ï¼ˆå¯ç”¨æ‹–åŠ¨æ¨¡å¼æ—¶ç”Ÿæ•ˆï¼‰
        const onGridPointerDown = (e) => {
          if (!panMode) return;
          setDragging(true);
          dragOriginRef.current = { x: e.clientX, y: e.clientY };
          try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
          e.preventDefault();
        };
        const onGridPointerMove = (e) => {
          if (!panMode || !dragging) return;
          const orig = dragOriginRef.current;
          const dx = e.clientX - orig.x;
          const dy = e.clientY - orig.y;
          setPan(prev => ({ x: prev.x + dx, y: prev.y + dy }));
          dragOriginRef.current = { x: e.clientX, y: e.clientY };
        };
        const endGridDrag = (e) => {
          if (!dragging) return;
          setDragging(false);
          try { e.currentTarget.releasePointerCapture(e.pointerId); } catch {}
        };

        const handleBoardClick = (e) => {
          if (winner != null) return;
          
          // é˜²æ­¢ç§»åŠ¨ç«¯åŒé‡è§¦å‘
          e.preventDefault();
          // å¯ç”¨æ‹–åŠ¨æ¨¡å¼æ—¶ï¼Œé˜»æ­¢è½å­ï¼Œé¿å…è¯¯è§¦
          if (panMode || dragging) return;
          
          const rect = e.currentTarget.getBoundingClientRect();
          // æ˜¾ç¤ºåæ ‡ï¼ˆå·²å—ç¼©æ”¾å½±å“ï¼‰
          const xScaled = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
          const yScaled = Math.max(0, Math.min(rect.height, e.clientY - rect.top));
          // è½¬å›åŸºç¡€åæ ‡ï¼šé™¤ä»¥ç¼©æ”¾å› å­
          const gridEl = e.currentTarget;
          const baseW = gridEl.offsetWidth;
          const csBase = baseW / (SIZE - 1);
          const xBase = xScaled / zoom;
          const yBase = yScaled / zoom;
          let col = Math.round(xBase / csBase);
          let row = Math.round(yBase / csBase);
          col = Math.max(0, Math.min(SIZE-1, col));
          row = Math.max(0, Math.min(SIZE-1, row));

          // æ™®é€šæ¨¡å¼ï¼šä»…è½å­ä¸è½®æ¢ï¼Œä¸å«æŠ€èƒ½/å†»ç»“
          if (gameMode === 'normal') {
            if (players[currentIndex]?.type === 'ai') return;
            if (board[row][col]) return;
            const pid = currentIndex; // ç”¨ç©å®¶ç´¢å¼•æ ‡è®°æ£‹ç›˜
            setBoard(prev=>{
              const next = prev.map(r=>r.slice());
              next[row][col] = pid;
              return next;
            });
            setLastMove({ row, col });
            setCurrentIndex(i => (i + 1) % players.length);
            return;
          }

          // Skill targeting mode
          if (skillMode) {
            const other = current === 'black' ? 'white' : 'black';
            if (skillMode.type === 'remove') {
              if (board[row][col] === other) {
                setBoard(prev => {
                  const next = prev.map(r=>r.slice());
                  next[row][col] = null;
                  return next;
                });
                setSkillsUsed(s => ({ ...s, [current]: { ...s[current], remove:true } }));
                setSkillMode(null);
                toast.show('æ£‹å­è¢«ä¸¢è¿›äº†ä»€åˆ¹æµ·ï¼Œä½ å¯ä»¥å†è½å­ä¸€æ¬¡');
                // é£æ²™èµ°çŸ³æŠ€èƒ½ï¼šç§»é™¤æ£‹å­åä¸åˆ‡æ¢å›åˆï¼Œå½“å‰ç©å®¶å¯ä»¥å†è½å­ä¸€æ¬¡
              }
              return;
            }
            if (skillMode.type === 'add') {
              if (!board[row][col]) {
                placePiece(row, col, current);
                setSkillsUsed(s => ({ ...s, [current]: { ...s[current], add:true } }));
                setSkillMode(null);
                toast.show('ç¥æ¥ä¹‹ç¬”å·²ä½¿ç”¨ï¼Œä½ å¯ä»¥å†è½å­ä¸€æ¬¡');
                // ç¥æ¥ä¹‹ç¬”æŠ€èƒ½ï¼šæ”¾ç½®æ£‹å­åä¸åˆ‡æ¢å›åˆï¼Œå½“å‰ç©å®¶å¯ä»¥å†è½å­ä¸€æ¬¡
              }
              return;
            }
            if (skillMode.type === 'swap') {
              if (skillMode.step === 1) {
                // ç¬¬ä¸€æ­¥ï¼šé€‰æ‹©å·±æ–¹æ£‹å­
                if (board[row][col] === current) {
                  // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»çš„æ˜¯å·²é€‰ä¸­çš„æ£‹å­
                  if (selectedPiece && selectedPiece.r === row && selectedPiece.c === col) {
                    // å–æ¶ˆé€‰ä¸­
                    setSelectedPiece(null);
                    toast.show('å·²å–æ¶ˆé€‰æ‹©ï¼Œè¯·é‡æ–°é€‰æ‹©å·±æ–¹æ£‹å­');
                  } else {
                    // é€‰ä¸­æ–°çš„æ£‹å­ï¼ˆåŒ…æ‹¬é‡æ–°é€‰æ‹©ï¼‰
                    setSkillMode({ type:'swap', step:2, first:{ r:row, c:col } });
                    setSelectedPiece({ r: row, c: col }); // è®¾ç½®é€‰ä¸­çš„æ£‹å­
                    toast.show('å·²é‡æ–°é€‰æ‹©ï¼Œç°åœ¨è¯·é€‰æ‹©å¯¹æ–¹æ£‹å­è¿›è¡Œäº¤æ¢');
                  }
                }
                return;
              } else if (skillMode.step === 2) {
                // ç¬¬äºŒæ­¥ï¼šé€‰æ‹©å¯¹æ–¹æ£‹å­è¿›è¡Œäº¤æ¢ï¼›å…è®¸å–æ¶ˆæˆ–æ”¹é€‰å·±æ–¹æ£‹å­
                // ç‚¹å‡»å·±æ–¹æ£‹å­ï¼šå–æ¶ˆæˆ–æ”¹é€‰
                if (board[row][col] === current) {
                  // ç‚¹å‡»åŒä¸€ä¸ªå·±æ–¹æ£‹å­ï¼šå–æ¶ˆé€‰ä¸­å¹¶å›åˆ°ç¬¬ä¸€æ­¥
                  if (selectedPiece && selectedPiece.r === row && selectedPiece.c === col) {
                    setSelectedPiece(null);
                    setSkillMode({ type:'swap', step:1 });
                    toast.show('å·²å–æ¶ˆé€‰æ‹©ï¼Œè¯·é‡æ–°é€‰æ‹©å·±æ–¹æ£‹å­');
                    return;
                  }
                  // ç‚¹å‡»å…¶ä»–å·±æ–¹æ£‹å­ï¼šæ”¹é€‰ä¸ºæ–°çš„å·±æ–¹æ£‹å­ï¼Œä¿æŒç¬¬äºŒæ­¥çŠ¶æ€
                  setSelectedPiece({ r: row, c: col });
                  setSkillMode({ type:'swap', step:2, first:{ r:row, c:col } });
                  toast.show('å·²é‡æ–°é€‰æ‹©ï¼Œç°åœ¨è¯·é€‰æ‹©å¯¹æ–¹æ£‹å­è¿›è¡Œäº¤æ¢');
                  return;
                }

                // ç‚¹å‡»å¯¹æ–¹æ£‹å­ï¼šæ‰§è¡Œäº¤æ¢
                if (board[row][col] === other) {
                  const a = skillMode.first;
                  setBoard(prev => {
                    const next = prev.map(r=>r.slice());
                    next[a.r][a.c] = other;
                    next[row][col] = current;
                    return next;
                  });
                  setSkillsUsed(s => ({ ...s, [current]: { ...s[current], swap:true } }));
                  setSkillMode(null);
                  setSelectedPiece(null); // æ¸…é™¤é€‰ä¸­çŠ¶æ€
                  toast.show('ç§»å½¢æ¢å½±å·²å®Œæˆï¼Œä½ å¯ä»¥å†è½å­ä¸€æ¬¡');
                  // ç§»å½¢æ¢å½±æŠ€èƒ½ï¼šäº¤æ¢å®Œæˆåä¸åˆ‡æ¢å›åˆï¼Œå½“å‰ç©å®¶å¯ä»¥å†è½å­ä¸€æ¬¡
                }
                return;
              }
            }
          }

          // Freeze skip check
          if (gameMode === 'skill' && frozen[current]) {
            setFrozen(prev => ({ ...prev, [current]: false }));
            setCurrent(c => c === 'black' ? 'white' : 'black');
            return;
          }

          // Normal placement
          if (board[row][col] || winner) return; // å¦‚æœä½ç½®å·²å ç”¨æˆ–æ¸¸æˆç»“æŸï¼Œç›´æ¥è¿”å›
          
          if (gameMode === 'skill') {
            setBoard(prev => {
              const next = prev.map(r=>r.slice());
              next[row][col] = current;
              return next;
            });
            setLastMove({ row, col });
            const nextTurn = current === 'black' ? 'white' : 'black';
            if (frozen[nextTurn]) {
              // auto-skip opponent: clear freeze and keep current turn
              setFrozen(prev => ({ ...prev, [nextTurn]: false }));
              // ä¿æŒå½“å‰ç©å®¶ç»§ç»­ä¸‹æ£‹ï¼Œä¸åˆ‡æ¢
            } else {
              setCurrent(nextTurn);
            }
          }
        };

        React.useEffect(()=>{
          if (lastMove) {
            const w = calcWin(board, lastMove.row, lastMove.col);
            if (w != null) setWinner(w);
          }
        }, [board, lastMove]);

        // æ™®é€šæ¨¡å¼ï¼šAI è‡ªåŠ¨å›åˆ
        React.useEffect(()=>{
          if (gameMode !== 'normal' || winner != null) return;
          const cur = players[currentIndex];
          if (!cur || cur.type !== 'ai') return;
          if (aiThinking) return;
          setAiThinking(true);
          setTimeout(()=>{
            const move = chooseAIMove(board, cur.id, cur.difficulty || 'easy');
            if (move) {
              const {r,c}=move;
              if(!board[r][c]){
                placeNormalAt(r,c,cur.id);
              }
            }
            setAiThinking(false);
          }, 350);
        }, [gameMode, currentIndex, board, players, winner, aiThinking]);

        React.useEffect(()=>{
          if (winner != null) {
            const name = gameMode === 'skill'
              ? (winner === 'black' ? names.black : names.white)
              : (players[winner]?.name || 'ç©å®¶');
            toast.show(`${name} è·èƒœï¼æ­å–œè¿æˆäº”å­ï¼`);
          }
        }, [winner, gameMode, players]);

        const reset = () => {
          setBoard(createEmptyBoard());
          setWinner(null);
          setLastMove(null);
          setSelectedPiece(null);
          if (gameMode === 'skill') {
            setCurrent('black');
            setFrozen({ black:false, white:false });
            setSkillsUsed({ black: { remove:false, freeze:false, instant:false, swap:false, add:false }, white: { remove:false, freeze:false, instant:false, swap:false, add:false } });
            setSkillMode(null);
          } else if (gameMode === 'normal') {
            setCurrentIndex(0);
            setAiThinking(false);
          }
        };

        const startSkillGame = () => {
          setGameMode('skill');
          reset();
        };
        const startNormalGame = () => {
          const cfg = normalConfig.players.filter(Boolean).slice(0, normalConfig.count);
          if (cfg.length < 2) { toast.show('æ™®é€šæ¨¡å¼è‡³å°‘éœ€è¦2ä½ç©å®¶'); return; }
          const ps = cfg.map((p,i)=>({ ...p, id:i }));
          setPlayers(ps);
          setGameMode('normal');
          setBoard(createEmptyBoard());
          setWinner(null);
          setLastMove(null);
          setCurrentIndex(0);
          setSkillMode(null);
          setAiThinking(false);
        };

        // Skills
        const useRemove = () => {
          if (winner) return;
          if (skillsUsed[current].remove) return;
          setSkillMode({ type:'remove' });
          setSelectedPiece(null); // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
          toast.show('è¯·é€‰æ‹©è¦ç§»é™¤çš„å¯¹æ‰‹æ£‹å­');
        };

        const useFreeze = () => {
          if (winner) return;
          if (skillsUsed[current].freeze) return;
          const other = current === 'black' ? 'white' : 'black';
          setFrozen(prev => ({ ...prev, [other]: true }));
          setSkillsUsed(s => ({ ...s, [current]: { ...s[current], freeze:true } }));
        };

        const useInstant = () => {
          if (winner) return;
          if (skillsUsed[current].instant) return;
          setSkillsUsed(s => ({ ...s, [current]: { ...s[current], instant:true } }));
          setWinner(current);
        };

        const useSwap = () => {
          if (winner) return;
          if (skillsUsed[current].swap) return;
          setSkillMode({ type:'swap', step:1 });
          setSelectedPiece(null); // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
          toast.show('è¯·é€‰æ‹©å·±æ–¹æ£‹å­ï¼ˆå¯é‡æ–°é€‰æ‹©æˆ–ç‚¹å‡»å·²é€‰ä¸­æ£‹å­å–æ¶ˆï¼‰');
        };

        const useAdd = () => {
          if (winner) return;
          if (skillsUsed[current].add) return;
          setSkillMode({ type:'add' });
          setSelectedPiece(null); // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
          toast.show('é€‰æ‹©ä»»æ„ä½ç½®æ”¾ç½®ä¸€å­');
        };

        const pieces = [];
        const gridEl = document.querySelector('.grid');
        const cs = gridEl ? (gridEl.offsetWidth) / (SIZE - 1) : 0;

        for (let r=0;r<SIZE;r++) {
          for (let c=0;c<SIZE;c++) {
            const v = board[r][c];
            if (v == null) continue;
            const x = c * cs;
            const y = r * cs;
            const isSelected = selectedPiece && selectedPiece.r === r && selectedPiece.c === c;
            const stoneClass = gameMode === 'skill' ? `stone ${v}${isSelected ? ' selected' : ''}` : `stone${isSelected ? ' selected' : ''}`;
            const stoneStyle = gameMode === 'normal' ? { background: players[v]?.color || '#ffffff' } : undefined;
            pieces.push(
              <div key={`${r}-${c}`} className="piece" style={{ left: x, top: y }}>
                <div className={stoneClass} style={stoneStyle} />
              </div>
            );
          }
        }

        const skillsPanel = (
          <div className="skill-grid">
            <div className="skill-card">
              <h4>é£æ²™èµ°çŸ³</h4>
              <p className="count">å‰©ä½™ï¼š{skillsUsed[current].remove ? 0 : 1}</p>
              <button className="btn skill" disabled={skillsUsed[current].remove || !!winner} onClick={useRemove}>ç§»é™¤å¯¹æ‰‹ä»»æ„ä¸€æšæ£‹å­</button>
            </div>
            <div className="skill-card">
              <h4>é™å¦‚æ­¢æ°´</h4>
              <p className="count">å‰©ä½™ï¼š{skillsUsed[current].freeze ? 0 : 1}</p>
              <button className="btn skill" disabled={skillsUsed[current].freeze || !!winner} onClick={useFreeze}>å†»ç»“å¯¹æ–¹ä¸€å›åˆ</button>
            </div>
            <div className="skill-card">
              <h4>åŠ›æ‹”å±±å…®</h4>
              <p className="count">å‰©ä½™ï¼š{skillsUsed[current].instant ? 0 : 1}</p>
              <button className="btn skill" disabled={skillsUsed[current].instant || !!winner} onClick={useInstant}>ç»ˆææŠ€èƒ½ï¼šç›´æ¥è·å¾—èƒœåˆ©</button>
            </div>
            <div className="skill-card">
              <h4>ç§»å½¢æ¢å½±</h4>
              <p className="count">å‰©ä½™ï¼š{skillsUsed[current].swap ? 0 : 1}</p>
              <button className="btn skill" disabled={skillsUsed[current].swap || !!winner} onClick={useSwap}>äº¤æ¢åŒæ–¹ä¸€æšæ£‹å­</button>
            </div>
            <div className="skill-card">
              <h4>ç¥æ¥ä¹‹ç¬”</h4>
              <p className="count">å‰©ä½™ï¼š{skillsUsed[current].add ? 0 : 1}</p>
              <button className="btn skill" disabled={skillsUsed[current].add || !!winner} onClick={useAdd}>åœ¨ä»»æ„ä½ç½®æ”¾ç½®ä¸€å­</button>
            </div>
          </div>
        );

        return (
          <div className={`container${!gameMode ? ' start' : gameMode === 'normal' ? ' normal' : ''}`}>
            {!gameMode && (
              <div className="start-wrap">
                <div className="header" style={{marginBottom: '12px'}}>
                  <div className="title">é€‰æ‹©æ¸¸æˆæ¨¡å¼</div>
                </div>
                <div className="mode-choices">
                  <div className="mode-card">
                    <h3>æ™®é€šäº”å­æ£‹æ¨¡å¼</h3>
                    <p className="desc">è‡ªç”±è®¾ç½®ç©å®¶æ•°é‡ã€åç§°ä¸æ£‹å­é¢œè‰²ã€‚</p>
                    <div className="actions">
                      <button className="btn success" onClick={()=>setShowNormalConfig(true)}>é…ç½®å¹¶å¼€å§‹</button>
                    </div>
                  </div>
                  <div className="mode-card">
                    <h3>æŠ€èƒ½äº”å­æ£‹æ¨¡å¼</h3>
                    <p className="desc">åŒ…å«æŠ€èƒ½é¢æ¿ä¸ç‰¹æ®Šè§„åˆ™ï¼Œå½“å‰é¡µé¢çš„ç©æ³•ã€‚</p>
                    <div className="actions">
                      <button className="btn accent" onClick={startSkillGame}>è¿›å…¥æŠ€èƒ½æ¨¡å¼</button>
                    </div>
                  </div>
                </div>
              </div>
            )}
            {gameMode && (
            <div className="card">
              <div className="header">
                <div className="left">
                  <button className="icon-btn" title="è¿”å›æ¨¡å¼é€‰æ‹©" aria-label="è¿”å›æ¨¡å¼é€‰æ‹©" onClick={()=>{ setGameMode(null); setShowRules(false); setShowNormalConfig(false); }}>
                    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                      <path d="M3 10.5L12 3l9 7.5" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                      <path d="M5 10.5v9h14v-9" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                      <path d="M10 19.5v-5h4v5" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                    </svg>
                  </button>
                  <div className="title">
                  {gameMode === 'skill' ? (
                    <>
                      <span>æŠ€èƒ½äº” vs å­ç¥º</span>
                      <span className="badge black">é»‘ï¼šæŠ€èƒ½äº”</span>
                      <span className="badge white">ç™½ï¼šå­ç¥º</span>
                    </>
                  ) : (
                    <>
                      <span>æ™®é€šæ¨¡å¼</span>
                      {players.map((p)=> (
                        <span key={`h-${p.id}`} className="badge" style={{borderColor:'rgba(255,255,255,0.25)'}}>
                          {p.name}{p.type === 'ai' ? 'ï¼ˆç”µè„‘ï¼‰' : ''}
                          <span className="color-dot" style={{background:p.color}}></span>
                        </span>
                      ))}
                    </>
                  )}
                  </div>
                </div>
              <div className="row">
                  <button className="btn" onClick={()=>setShowRules(true)}>è§„åˆ™è¯´æ˜</button>
                  <button className="btn" onClick={reset}>é‡æ–°å¼€å§‹</button>
                  <button className="btn" onClick={()=>setPanMode(m=>!m)}>{panMode ? 'æ‹–åŠ¨ï¼šå¼€' : 'æ‹–åŠ¨ï¼šå…³'}</button>
                  <button className="btn" onClick={()=>setZoom(z=>Math.min(2.5, +(z+0.2).toFixed(2)))}>æ”¾å¤§</button>
                  <button className="btn" onClick={()=>setZoom(z=>Math.max(0.6, +(z-0.2).toFixed(2)))}>ç¼©å°</button>
                  <button className="btn" onClick={()=>{ setZoom(1); setPan({x:0,y:0}); }}>å¤ä½</button>
              </div>
              </div>
              {/* å¤§å­—æŠ¥æ ·å¼çš„å½“å‰ç©å®¶æ˜¾ç¤º */}
              <div className="current-player-banner">
                {winner != null ? (
                  <div className="winner-banner">
                    {gameMode === 'skill' ? (
                      <>ğŸ‰ èƒœè€…ï¼š{winner === 'black' ? names.black : names.white} ğŸ‰</>
                    ) : (
                      <>ğŸ‰ èƒœè€…ï¼š{players[winner]?.name || 'ç©å®¶'} ğŸ‰</>
                    )}
                  </div>
                ) : (
                  <div className="player-turn">
                    {gameMode === 'skill' ? (
                      <>è½®åˆ°ï¼š{current === 'black' ? `${names.black}ï¼ˆé»‘æ£‹ï¼‰` : `${names.white}ï¼ˆç™½æ£‹ï¼‰`}
                        {frozen[current] && <span className="frozen-notice">ï¼ˆæœ¬å›åˆå†»ç»“ï¼Œè‡ªåŠ¨è·³è¿‡ï¼‰</span>}</>
                    ) : (
                      <>è½®åˆ°ï¼š{players[currentIndex]?.name || '-'}
                        {players[currentIndex]?.type === 'ai' && (
                          <span>ï¼ˆç”µè„‘ï¼š{players[currentIndex]?.difficulty === 'hard' ? 'å›°éš¾' : (players[currentIndex]?.difficulty === 'medium' ? 'ä¸­ç­‰' : 'ç®€å•')}{aiThinking ? 'ï¼Œæ€è€ƒä¸­â€¦' : ''}ï¼‰</span>
                        )}
                        <span className="frozen-notice">ï¼ˆæ™®é€šæ¨¡å¼ï¼šæ— æŠ€èƒ½ï¼‰</span>
                      </>
                    )}
                  </div>
                )}
              </div>
              
              <div className="board-wrap">
                <div className="board">
                  <div
                    className="board-content"
                    onPointerDown={onGridPointerDown}
                    onPointerMove={onGridPointerMove}
                    onPointerUp={endGridDrag}
                    onPointerLeave={endGridDrag}
                    style={{
                      position:'absolute', inset:16,
                      transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
                      transformOrigin: 'center center',
                      cursor: panMode ? (dragging ? 'grabbing' : 'grab') : 'pointer',
                      touchAction: panMode ? 'none' : 'auto'
                    }}
                  >
                    <div className="grid" onClick={handleBoardClick} style={{position:'absolute', inset:0}}>
                      <canvas ref={canvasRef}/>
                    </div>
                    <div className="hint" style={{position:'absolute', inset:0}}>
                      {starPoints.map(([r,c]) => {
                        const x = c * cs; const y = r * cs;
                        return <div key={`star-${r}-${c}`} className="hint-dot" style={{ left: x, top: y }} />
                      })}
                    </div>
                    <div className="pieces" style={{position:'absolute', inset:0}}>{pieces}</div>
                  </div>
                </div>
              </div>
              <div className="footer">
                <div className="status">æœ€è¿‘è½å­ï¼š{lastMove ? `${lastMove.row+1}, ${lastMove.col+1}` : '-'}</div>
              </div>
            </div>
            )}

            {gameMode === 'skill' && (
              <div className="card">
                <div className="panel">
                  <h3>æŠ€èƒ½é¢æ¿</h3>
                  <p className="status">æ¯ç§æŠ€èƒ½æ¯å±€ä»…å¯ä½¿ç”¨ä¸€æ¬¡ã€‚å½“å‰ç©å®¶ï¼š{current==='black'?names.black:names.white}</p>
                  {skillsPanel}
                </div>
              </div>
            )}

            {showRules && (
              <div className="modal-backdrop" onClick={()=>setShowRules(false)}>
                <div className="modal" onClick={(e)=>e.stopPropagation()}>
                  <div className="header">
                    <div className="title">äº”å­æ£‹è§„åˆ™è¯´æ˜</div>
                    <button className="btn" onClick={()=>setShowRules(false)}>å…³é—­</button>
                  </div>
                  <div className="content">
                    <p>1. æ£‹ç›˜ä¸º15Ã—15ï¼ŒåŒæ–¹è½®æµåœ¨ç©ºä½å¤„è½å­ï¼Œç‡å…ˆå½¢æˆä»»æ„æ–¹å‘è¿ç»­äº”å­è€…è·èƒœã€‚</p>
                    <p>2. æ˜Ÿä½ä»…ä¸ºè§†è§‰å‚è€ƒï¼Œå¯åœ¨æ˜Ÿä½ä¸Šè½å­ã€‚</p>
                    <p>3. æŠ€èƒ½ç³»ç»Ÿï¼ˆæ¯ç§æ¯å±€ä¸€æ¬¡ï¼‰ï¼š</p>
                    <ul>
                      <li>é£æ²™èµ°çŸ³ï¼šç§»é™¤å¯¹æ‰‹ä»»æ„ä¸€æšæ£‹å­ã€‚</li>
                      <li>é™å¦‚æ­¢æ°´ï¼šå†»ç»“å¯¹æ–¹ä¸€å›åˆï¼Œå·±æ–¹å¯è¿ç»­ä¸‹ä¸¤æ­¥ï¼ˆé€šè¿‡è·³è¿‡å¯¹æ–¹å›åˆå®ç°ï¼‰ã€‚</li>
                      <li>åŠ›æ‹”å±±å…®ï¼šç»ˆææŠ€èƒ½ï¼Œç›´æ¥è·å¾—èƒœåˆ©ã€‚</li>
                      <li>ç§»å½¢æ¢å½±ï¼šäº¤æ¢åŒæ–¹å„ä¸€æšå·²è½å­ã€‚</li>
                      <li>ç¥æ¥ä¹‹ç¬”ï¼šåœ¨ä»»æ„ä½ç½®é¢å¤–æ”¾ç½®ä¸€å­ã€‚</li>
                    </ul>
                    <p>4. åœ¨ç§»åŠ¨ç«¯ï¼Œæ£‹ç›˜ä¸é¢æ¿ä¼šè‡ªé€‚åº”å¸ƒå±€ã€‚</p>
                  </div>
                </div>
              </div>
            )}

            {showNormalConfig && (
              <div className="modal-backdrop" onClick={()=>setShowNormalConfig(false)}>
                <div className="modal" onClick={(e)=>e.stopPropagation()}>
                  <div className="header">
                    <div className="title">æ™®é€šæ¨¡å¼é…ç½®</div>
                    <div className="row">
                      <button className="btn" onClick={()=>setShowNormalConfig(false)}>å–æ¶ˆ</button>
                      <button className="btn success" onClick={()=>{ startNormalGame(); setShowNormalConfig(false); }}>å¼€å§‹å¯¹å±€</button>
                    </div>
                  </div>
                  <div className="content">
                    <div className="form">
                      <div className="form-row">
                        <label>ç©å®¶äººæ•°ï¼ˆâ‰¥2ï¼‰ï¼š</label>
                        <input type="number" min={2} value={normalConfig.count} onChange={handleCountChange} onBlur={(e)=>ensureConfigCount(Math.max(2, Number(e.target.value)||2))} />
                      </div>
                      {normalConfig.players.map((p,i)=> (
                        <div key={`cfgm-${i}`} className="form-row">
                          <span>ç©å®¶{i+1}ï¼š</span>
                          <input type="text" value={p.name} onChange={(e)=>{
                            const v = e.target.value;
                            setNormalConfig(prev=>{ const arr = prev.players.slice(); arr[i] = { ...arr[i], name: v }; return { ...prev, players: arr }; });
                          }} />
                          <input type="color" value={p.color} onChange={(e)=>{
                            const v = e.target.value;
                            setNormalConfig(prev=>{ const arr = prev.players.slice(); arr[i] = { ...arr[i], color: v }; return { ...prev, players: arr }; });
                          }} />
                          <select value={p.type || 'human'} onChange={(e)=>{
                            const v = e.target.value;
                            setNormalConfig(prev=>{ const arr = prev.players.slice(); arr[i] = { ...arr[i], type: v }; return { ...prev, players: arr }; });
                          }}>
                            <option value="human">äººç±»</option>
                            <option value="ai">ç”µè„‘</option>
                          </select>
                          {p.type === 'ai' && (
                            <select value={p.difficulty || 'easy'} onChange={(e)=>{
                              const v = e.target.value;
                              setNormalConfig(prev=>{ const arr = prev.players.slice(); arr[i] = { ...arr[i], difficulty: v }; return { ...prev, players: arr }; });
                            }}>
                              <option value="easy">ç®€å•</option>
                              <option value="medium">ä¸­ç­‰</option>
                              <option value="hard">å›°éš¾</option>
                            </select>
                          )}
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              </div>
            )}

            {winner != null && (
              <div className="modal-backdrop" onClick={()=>{}}>
                <div className="modal" onClick={(e)=>e.stopPropagation()}>
                  <div className="header">
                    <div className="title">æ¸¸æˆç»“æŸ</div>
                    <button className="btn" onClick={reset}>é‡æ–°å¼€å§‹</button>
                  </div>
                  <div className="content">
                    <h3 style={{marginTop:0}}>
                      èƒœè€…ï¼š{gameMode === 'skill' ? (winner === 'black' ? names.black : names.white) : (players[winner]?.name || 'ç©å®¶')}
                    </h3>
                    <p>æ­å–œè¾¾æˆè¿ç»­äº”å­ï¼å¯ç‚¹å‡»å³ä¸Šè§’â€œé‡æ–°å¼€å§‹â€å†æˆ˜ä¸€å±€ã€‚</p>
                  </div>
                </div>
              </div>
            )}

            {toast.msg && <div className="toast">{toast.msg}</div>}
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App/>);
    </script>
  </body>
  </html>