<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>技能五 vs 子祺 - 五子棋对战</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css" />
    <style>
      :root {
        --bg-gradient: radial-gradient(1200px 800px at 10% 10%, #1f2937, #0b1020 60%, #050914);
        --card-bg: rgba(255,255,255,0.06);
        --card-border: rgba(255,255,255,0.12);
        --accent: #7c3aed;
        --accent-2: #06b6d4;
        --win: #22c55e;
        --lose: #ef4444;
        --text: #e5e7eb;
        --muted: #94a3b8;
        --grid: #334155;
        --black: #0f172a;
        --white: #e5e7eb;
        --shadow: 0 10px 30px rgba(0,0,0,0.25);
      }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--text);
        background: linear-gradient(120deg, #0b1020, #0a0f1e), var(--bg-gradient);
        background-blend-mode: overlay;
        min-height: 100vh;
        display: grid;
        place-items: center;
        overflow-x: hidden;
      }
      .container {
        width: min(1200px, 95vw);
        display: grid;
        grid-template-columns: 1fr 360px;
        gap: 20px;
      }
      @media (max-width: 980px) {
        .container { grid-template-columns: 1fr; }
      }
      .card {
        background: var(--card-bg);
        border: 1px solid var(--card-border);
        border-radius: 16px;
        box-shadow: var(--shadow);
        backdrop-filter: saturate(120%) blur(8px);
      }
      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        border-bottom: 1px solid var(--card-border);
      }
      .title {
        font-weight: 700;
        letter-spacing: 0.5px;
        display: flex; gap: 10px; align-items: center;
      }
      .badge { padding: 6px 10px; border-radius: 999px; font-size: 12px; color: #0a0f1e; }
      .badge.black { background: #facc15; }
      .badge.white { background: #a7f3d0; }
      .board-wrap { padding: 16px; }
      .board {
        aspect-ratio: 1 / 1;
        max-width: 720px;
        width: 100%;
        margin: 0 auto;
        background: linear-gradient(180deg, #e6c792, #c9a86a);
        border-radius: 12px;
        box-shadow: inset 0 0 0 2px rgba(0,0,0,0.2), var(--shadow);
        position: relative;
        overflow: hidden;
      }
      @media (max-width: 768px) {
        .board {
          max-width: 90vw;
          border-radius: 8px;
        }
      }
      .grid { position: absolute; inset: 16px; cursor: pointer; z-index: 1; }
      .grid canvas { width: 100%; height: 100%; display: block; pointer-events: none; }
      .pieces { position: absolute; inset: 16px; pointer-events: none; z-index: 3; }
      .piece {
        position: absolute;
        width: 28px; height: 28px;
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 3;
      }
      @media (max-width: 768px) {
        .piece {
          width: 20px; height: 20px;
        }
      }
      @media (max-width: 480px) {
        .piece {
          width: 16px; height: 16px;
        }
      }
      .stone {
        width: 100%; height: 100%;
        border-radius: 50%;
        box-shadow: 0 8px 18px rgba(0,0,0,0.35), inset 0 -4px 8px rgba(0,0,0,0.35), inset 0 4px 10px rgba(255,255,255,0.35);
        transition: transform 0.18s ease, box-shadow 0.2s ease;
        border: 1px solid rgba(0,0,0,0.35);
      }
      .stone.black { background: radial-gradient(circle at 35% 30%, #374151, #0b0f1a 70%); }
      .stone.white { background: radial-gradient(circle at 40% 35%, #f3f4f6, #cbd5e1 70%); }
      .hint { position: absolute; inset: 16px; pointer-events: none; z-index: 2; }
      .hint-dot {
        position: absolute; width: 10px; height: 10px; border-radius: 50%;
        background: rgba(0,0,0,0.35);
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      @media (max-width: 768px) {
        .hint-dot {
          width: 8px; height: 8px;
        }
      }
      @media (max-width: 480px) {
        .hint-dot {
          width: 6px; height: 6px;
        }
      }
      .controls { padding: 16px; display: grid; gap: 12px; }
      .row { display: flex; gap: 10px; align-items: center; justify-content: space-between; }
      .btn {
        padding: 10px 14px; border-radius: 10px; border: 1px solid var(--card-border);
        background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
        color: var(--text);
        cursor: pointer; transition: all .18s ease; font-weight: 600; letter-spacing: .2px;
      }
      .btn:hover { transform: translateY(-1px); box-shadow: var(--shadow); }
      .btn:disabled { opacity: .45; cursor: not-allowed; }
      .accent { border-color: rgba(124,58,237,.5); background: linear-gradient(180deg, rgba(124,58,237,.3), rgba(124,58,237,.1)); }
      .danger { border-color: rgba(239,68,68,.45); background: linear-gradient(180deg, rgba(239,68,68,.25), rgba(239,68,68,.08)); }
      .success { border-color: rgba(34,197,94,.45); background: linear-gradient(180deg, rgba(34,197,94,.25), rgba(34,197,94,.08)); }
      .panel { padding: 16px; }
      .status { font-family: JetBrains Mono, monospace; color: var(--muted); font-size: 13px; }
      .skill-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
      .skill-card { padding: 12px; border-radius: 12px; border: 1px dashed var(--card-border); background: rgba(255,255,255,0.10); }
      .skill-card h4 { margin: 6px 0; font-size: 14px; }
      .count { font-size: 12px; color: var(--muted); }
      .footer { padding: 10px 16px; border-top: 1px solid var(--card-border); display: flex; justify-content: space-between; align-items: center; }
      .link { color: #93c5fd; text-decoration: none; }
      .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.55); display: grid; place-items: center; }
      .modal { width: min(720px, 92vw); background: rgba(17,24,39,0.90); border: 1px solid rgba(255,255,255,0.20); border-radius: 18px; box-shadow: var(--shadow); }
      .modal .content { padding: 16px 18px; }
      .modal h3 { margin: 0; }
      .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,.7); color: #fff; padding: 10px 14px; border-radius: 999px; box-shadow: var(--shadow); }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel" data-type="module" data-presets="env,react">
      const SIZE = 15;

      const createEmptyBoard = () => Array.from({ length: SIZE }, () => Array(SIZE).fill(null));

      const starPoints = [
        [3,3],[3,11],[11,3],[11,11],[7,7]
      ];

      function useToast() {
        const [msg, setMsg] = React.useState(null);
        const show = React.useCallback((text) => {
          setMsg(text);
          setTimeout(() => setMsg(null), 1800);
        }, []);
        return { msg, show };
      }

      function drawGrid(canvas) {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        ctx.clearRect(0,0,rect.width, rect.height);
        ctx.strokeStyle = '#2b3547';
        ctx.lineWidth = 1;
        const padding = 0;
        const cellSize = (rect.width) / (SIZE - 1);
        for (let i = 0; i < SIZE; i++) {
          const pos = padding + i * cellSize;
          ctx.beginPath(); ctx.moveTo(padding, pos); ctx.lineTo(rect.width - padding, pos); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(pos, padding); ctx.lineTo(pos, rect.height - padding); ctx.stroke();
        }
        // star points
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        starPoints.forEach(([r,c]) => {
          const x = padding + c * cellSize;
          const y = padding + r * cellSize;
          ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fill();
        });
      }

      function calcWin(board, lastRow, lastCol) {
        if (lastRow == null || lastCol == null) return null;
        const color = board[lastRow][lastCol];
        if (!color) return null;
        const dirs = [[1,0],[0,1],[1,1],[1,-1]];
        const inBounds = (r,c)=> r>=0 && r<SIZE && c>=0 && c<SIZE;
        for (const [dr,dc] of dirs) {
          let count = 1;
          let r = lastRow+dr, c = lastCol+dc;
          while (inBounds(r,c) && board[r][c]===color) { count++; r+=dr; c+=dc; }
          r = lastRow-dr; c = lastCol-dc;
          while (inBounds(r,c) && board[r][c]===color) { count++; r-=dr; c-=dc; }
          if (count >= 5) return color;
        }
        return null;
      }

      function App(){
        const [board, setBoard] = React.useState(createEmptyBoard);
        const [current, setCurrent] = React.useState('black');
        const [names] = React.useState({ black: '技能五', white: '子祺' });
        const [frozen, setFrozen] = React.useState({ black:false, white:false });
        const [skillsUsed, setSkillsUsed] = React.useState({
          black: { remove:false, freeze:false, instant:false, swap:false, add:false },
          white: { remove:false, freeze:false, instant:false, swap:false, add:false },
        });
        const [winner, setWinner] = React.useState(null);
        const [lastMove, setLastMove] = React.useState(null);
        const [skillMode, setSkillMode] = React.useState(null); // { type: 'remove'|'add'|'swap', step?:1|2, first?:{r,c} }
        const [showRules, setShowRules] = React.useState(false);
        const toast = useToast();

        const canvasRef = React.useRef(null);
        React.useEffect(()=>{ if(canvasRef.current) drawGrid(canvasRef.current); });

        const cellSize = React.useMemo(()=>{
          const grid = document.querySelector('.grid');
          if (!grid) return 0; const rect = grid.getBoundingClientRect(); return (rect.width) / (SIZE - 1);
        }, [board]);

        const placePiece = (row,col,color) => {
          setBoard(prev => {
            if (prev[row][col]) return prev;
            const next = prev.map(r=>r.slice());
            next[row][col] = color;
            return next;
          });
          setLastMove({ row, col });
        };

        const handleBoardClick = (e) => {
          if (winner) return;
          const rect = e.currentTarget.getBoundingClientRect();
          const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
          const y = Math.max(0, Math.min(rect.height, e.clientY - rect.top));
          const cs = rect.width / (SIZE - 1);
          let col = Math.round(x / cs);
          let row = Math.round(y / cs);
          col = Math.max(0, Math.min(SIZE-1, col));
          row = Math.max(0, Math.min(SIZE-1, row));

          // Skill targeting mode
          if (skillMode) {
            const other = current === 'black' ? 'white' : 'black';
            if (skillMode.type === 'remove') {
              if (board[row][col] === other) {
                setBoard(prev => {
                  const next = prev.map(r=>r.slice());
                  next[row][col] = null;
                  return next;
                });
                setSkillsUsed(s => ({ ...s, [current]: { ...s[current], remove:true } }));
                setSkillMode(null);
                toast.show('棋子被丢进了什刹海');
              }
              return;
            }
            if (skillMode.type === 'add') {
              if (!board[row][col]) {
                placePiece(row, col, current);
                setSkillsUsed(s => ({ ...s, [current]: { ...s[current], add:true } }));
                setSkillMode(null);
              }
              return;
            }
            if (skillMode.type === 'swap') {
              if (skillMode.step !== 2) {
                if (board[row][col] === current) {
                  setSkillMode({ type:'swap', step:2, first:{ r:row, c:col } });
                }
                return;
              } else {
                if (board[row][col] === other) {
                  const a = skillMode.first;
                  setBoard(prev => {
                    const next = prev.map(r=>r.slice());
                    next[a.r][a.c] = other;
                    next[row][col] = current;
                    return next;
                  });
                  setSkillsUsed(s => ({ ...s, [current]: { ...s[current], swap:true } }));
                  setSkillMode(null);
                }
                return;
              }
            }
          }

          // Freeze skip check
          if (frozen[current]) {
            setFrozen(prev => ({ ...prev, [current]: false }));
            setCurrent(c => c === 'black' ? 'white' : 'black');
            return;
          }

          // Normal placement
          if (board[row][col] || winner) return; // 如果位置已占用或游戏结束，直接返回
          
          setBoard(prev => {
            const next = prev.map(r=>r.slice());
            next[row][col] = current;
            return next;
          });
          setLastMove({ row, col });
          const nextTurn = current === 'black' ? 'white' : 'black';
          if (frozen[nextTurn]) {
            // auto-skip opponent: clear freeze and keep current turn
            setFrozen(prev => ({ ...prev, [nextTurn]: false }));
            // 保持当前玩家继续下棋，不切换
          } else {
            setCurrent(nextTurn);
          }
        };

        React.useEffect(()=>{
          if (lastMove) {
            const w = calcWin(board, lastMove.row, lastMove.col);
            if (w) setWinner(w);
          }
        }, [board, lastMove]);

        React.useEffect(()=>{
          if (winner) {
            const name = winner === 'black' ? names.black : names.white;
            toast.show(`${name} 获胜！恭喜连成五子！`);
          }
        }, [winner]);

        const reset = () => {
          setBoard(createEmptyBoard());
          setCurrent('black');
          setFrozen({ black:false, white:false });
          setSkillsUsed({ black: { remove:false, freeze:false, instant:false, swap:false, add:false }, white: { remove:false, freeze:false, instant:false, swap:false, add:false } });
          setWinner(null);
          setLastMove(null);
        };

        // Skills
        const useRemove = () => {
          if (winner) return;
          if (skillsUsed[current].remove) return;
          setSkillMode({ type:'remove' });
          toast.show('请选择要移除的对手棋子');
        };

        const useFreeze = () => {
          if (winner) return;
          if (skillsUsed[current].freeze) return;
          const other = current === 'black' ? 'white' : 'black';
          setFrozen(prev => ({ ...prev, [other]: true }));
          setSkillsUsed(s => ({ ...s, [current]: { ...s[current], freeze:true } }));
        };

        const useInstant = () => {
          if (winner) return;
          if (skillsUsed[current].instant) return;
          setSkillsUsed(s => ({ ...s, [current]: { ...s[current], instant:true } }));
          setWinner(current);
        };

        const useSwap = () => {
          if (winner) return;
          if (skillsUsed[current].swap) return;
          setSkillMode({ type:'swap', step:1 });
          toast.show('先选择己方棋子，再选择对方棋子');
        };

        const useAdd = () => {
          if (winner) return;
          if (skillsUsed[current].add) return;
          setSkillMode({ type:'add' });
          toast.show('选择任意位置放置一子');
        };

        const pieces = [];
        const gridRect = document.querySelector('.grid')?.getBoundingClientRect();
        const cs = gridRect ? (gridRect.width) / (SIZE - 1) : 0;

        for (let r=0;r<SIZE;r++) {
          for (let c=0;c<SIZE;c++) {
            const v = board[r][c];
            if (!v) continue;
            const x = c * cs;
            const y = r * cs;
            pieces.push(
              <div key={`${r}-${c}`} className="piece" style={{ left: x, top: y }}>
                <div className={`stone ${v}`} />
              </div>
            );
          }
        }

        const skillsPanel = (
          <div className="skill-grid">
            <div className="skill-card">
              <h4>飞沙走石</h4>
              <p className="count">剩余：{skillsUsed[current].remove ? 0 : 1}</p>
              <button className="btn danger" disabled={skillsUsed[current].remove || !!winner} onClick={useRemove}>移除对手任意一枚棋子</button>
            </div>
            <div className="skill-card">
              <h4>静如止水</h4>
              <p className="count">剩余：{skillsUsed[current].freeze ? 0 : 1}</p>
              <button className="btn accent" disabled={skillsUsed[current].freeze || !!winner} onClick={useFreeze}>冻结对方一回合</button>
            </div>
            <div className="skill-card">
              <h4>力拔山兮</h4>
              <p className="count">剩余：{skillsUsed[current].instant ? 0 : 1}</p>
              <button className="btn success" disabled={skillsUsed[current].instant || !!winner} onClick={useInstant}>终极技能：直接获得胜利</button>
            </div>
            <div className="skill-card">
              <h4>移形换影</h4>
              <p className="count">剩余：{skillsUsed[current].swap ? 0 : 1}</p>
              <button className="btn" disabled={skillsUsed[current].swap || !!winner} onClick={useSwap}>交换双方一枚棋子</button>
            </div>
            <div className="skill-card">
              <h4>神来之笔</h4>
              <p className="count">剩余：{skillsUsed[current].add ? 0 : 1}</p>
              <button className="btn" disabled={skillsUsed[current].add || !!winner} onClick={useAdd}>在任意位置放置一子</button>
            </div>
          </div>
        );

        return (
          <div className="container">
            <div className="card">
              <div className="header">
                <div className="title">
                  <span>技能五 vs 子祺</span>
                  <span className="badge black">黑：技能五</span>
                  <span className="badge white">白：子祺</span>
                </div>
                <div className="row">
                  <button className="btn" onClick={()=>setShowRules(true)}>规则说明</button>
                  <button className="btn" onClick={reset}>重新开始</button>
                </div>
              </div>
              <div className="board-wrap">
                <div className="board">
                  <div className="grid" onClick={handleBoardClick} onTouchStart={(e)=>{ const t=e.touches[0]; handleBoardClick({ currentTarget:e.currentTarget, clientX:t.clientX, clientY:t.clientY }); }}>
                    <canvas ref={canvasRef}/>
                  </div>
                  <div className="hint">
                    {starPoints.map(([r,c]) => {
                      const x = c * cs; const y = r * cs;
                      return <div key={`star-${r}-${c}`} className="hint-dot" style={{ left: x, top: y }} />
                    })}
                  </div>
                  <div className="pieces">{pieces}</div>
                </div>
              </div>
              <div className="footer">
                <div className="status">
                  {winner ? (
                    <span>胜者：{winner === 'black' ? names.black : names.white}</span>
                  ) : (
                    <span>当前回合：{current === 'black' ? `${names.black}（黑）` : `${names.white}（白）`}{frozen[current]? '（本回合冻结，自动跳过）' : ''}</span>
                  )}
                </div>
                <div className="status">最近落子：{lastMove ? `${lastMove.row+1}, ${lastMove.col+1}` : '-'}</div>
              </div>
            </div>

            <div className="card">
              <div className="panel">
                <h3>技能面板</h3>
                <p className="status">每种技能每局仅可使用一次。当前玩家：{current==='black'?names.black:names.white}</p>
                {skillsPanel}
              </div>
            </div>

            {showRules && (
              <div className="modal-backdrop" onClick={()=>setShowRules(false)}>
                <div className="modal" onClick={(e)=>e.stopPropagation()}>
                  <div className="header">
                    <div className="title">五子棋规则说明</div>
                    <button className="btn" onClick={()=>setShowRules(false)}>关闭</button>
                  </div>
                  <div className="content">
                    <p>1. 棋盘为15×15，双方轮流在空位处落子，率先形成任意方向连续五子者获胜。</p>
                    <p>2. 星位仅为视觉参考，可在星位上落子。</p>
                    <p>3. 技能系统（每种每局一次）：</p>
                    <ul>
                      <li>飞沙走石：移除对手任意一枚棋子。</li>
                      <li>静如止水：冻结对方一回合，己方可连续下两步（通过跳过对方回合实现）。</li>
                      <li>力拔山兮：终极技能，直接获得胜利。</li>
                      <li>移形换影：交换双方各一枚已落子。</li>
                      <li>神来之笔：在任意位置额外放置一子。</li>
                    </ul>
                    <p>4. 在移动端，棋盘与面板会自适应布局。</p>
                  </div>
                </div>
              </div>
            )}

            {winner && (
              <div className="modal-backdrop" onClick={()=>{}}>
                <div className="modal" onClick={(e)=>e.stopPropagation()}>
                  <div className="header">
                    <div className="title">游戏结束</div>
                    <button className="btn" onClick={reset}>重新开始</button>
                  </div>
                  <div className="content">
                    <h3 style={{marginTop:0}}>胜者：{winner === 'black' ? names.black : names.white}</h3>
                    <p>恭喜达成连续五子！可点击右上角“重新开始”再战一局。</p>
                  </div>
                </div>
              </div>
            )}

            {toast.msg && <div className="toast">{toast.msg}</div>}
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App/>);
    </script>
  </body>
  </html>